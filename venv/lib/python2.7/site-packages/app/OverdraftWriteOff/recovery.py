from datetime 					import datetime
from .models 					import *
from flask 						import flash
from app.mktcore.wtfimports 	import *
from app.mktcore.imports 			import *
from app.Account.models 			import *
from decimal import Decimal
import app.tools.user 				as mktuser
import app.tools.mktdate 			as mktdate
import app.tools.mktaudit 			as mktaudit
import app.tools.mktparam 			as mktparam
import app.tools.mktteller 			as mktteller
import app.tools.mktsetting 		as mktsetting
import app.tools.bank.mktoverdraft 	as mktoverdraft

@app.route("/Morakot/LoadODAccountInfo", methods=['GET'])
@checkLogOutSession
@checkLogOutTime
def loadODAccountInfo():
	try:
		ContractID 	= 	request.args.get("ContractID")
		ODWObj 		=	MKT_OVERDRAFT_WRITE_OFF.query.get(ContractID)
		Account 	=	''
		Currency 	=	''
		AccBalance 	=	0
		RecoveryAmt =	0
		if ODWObj:
			Account 		= 	ODWObj.Account
			Currency 		=	ODWObj.Currency
			AccountObj 		=	MKT_ACCOUNT.query.get(Account)
			if AccountObj:
				AccBalance 	=	abs(AccountObj.Balance)

			RecoveryAmt = ODWObj.AmountForRecovery
			if AccBalance <= RecoveryAmt:
				RecoveryAmt = AccBalance
			
			CurrencyObj =	mktmoney.getCurrencyObj(Currency)
			RecoveryAmt =	mktmoney.toMoney(float(RecoveryAmt),CurrencyObj)
			AccBalance  =	mktmoney.toMoney(float(AccBalance),CurrencyObj)

		return jsonify(RecoveryAmt=str(RecoveryAmt),AccBalance=str(AccBalance),Currency=Currency,Account=Account)
	except:
		raise
def loadBankDate():
	try:
		return mktdate.getBankDate()
	except:
		raise

class FRM_OVERDRAFT_RECOVERY(exform):
	ContractID 			= 	TextField(requiredlabel("Contract ID", "*"), [validators.Required()])
	Account				= 	TextField(requiredlabel("Account", "*"), [validators.Required()])
	Currency 			=	TextField(requiredlabel("Currency", "*"), [validators.Required()])
	TranDate			=	TextField(requiredlabel("Transation Date", "*"), [validators.Required()], default=loadBankDate)
	AccBalance			=	TextField(requiredlabel("Account Balance", "*"), [validators.Required()], default=0)
	RecoveryAmount		=	TextField(requiredlabel("Recovery Amount", "*"), [validators.Required()], default=0)

	def validate_RecoveryAmount(form, field):
		Amount = Decimal(str(field.data).replace(',',''))
		AccAmount = Decimal(str(form.AccBalance.data).replace(',',''))
		if Amount <= 0:
			raise ValidationError('Cannot smaller or equal zero')

		if AccAmount < Amount:
			raise ValidationError('Cannot greater than account balance')

	def validate_AccBalance(form, field):
		Amount = Decimal(str(field.data).replace(',',''))
		if Amount <= 0:
			raise ValidationError('Cannot smaller or equal zero')

	@staticmethod
	def setDisable():
		return [('Account'), ('Currency'), ('TranDate'), ('AccBalance')]

	@staticmethod
	def moneyField():
		return [('RecoveryAmount', 'Currency'), ('AccBalance', 'Currency')]

	@staticmethod
	def hotField():
		hotfield = []
		fielddisplay 	= "$('#Currency').val(data.Currency);$('#Account').val(data.Account)"
		fielddisplay 	+= ";$('#AccBalance').val(data.AccBalance);$('#RecoveryAmount').val(data.RecoveryAmt)"
		varname 		= "ContractID:$('#ContractID').val()"
		fun 			= ["ContractID", varname, fielddisplay, "/Morakot/LoadODAccountInfo", "blur"]
		hotfield.append(fun)

		return hotfield

	@staticmethod
	def formReadOnly():
		return "AUTH"

	@staticmethod
	def beforeAuthorize():
		try:
			ID 				= 	g.formID
			ODWObj 			= 	MKT_OVERDRAFT_WRITE_OFF_INAU.query.get(ID)
			ODWID  			=	ODWObj.ContractID
			TranDate  		=	ODWObj.TranDate
			RecoveryAmount 	=	ODWObj.RecoveryAmount
			return setODRecovery(ODWID, RecoveryAmount,TranDate)
		
		except Exception as e:
			raise e

	@staticmethod
	def reverseRec():
		flash(msg_error + " Record not allow to reverse.")
		return False, ""

	@staticmethod
	def beforeInsert():
		ID 				= 	request.form['ID']
		NumOfAuth 		= 	g.getNAuthorize
		Resource 		= 	"INAU"
		if int(NumOfAuth) == 0:
			CID 			= request.form['ContractID']
			RecoveryAmount 	= Decimal(request.form['RecoveryAmount'].replace(',',''))
			AccBalance 		= request.form['AccBalance']
			TranDate 		= request.form['TranDate']
			return setODRecovery(CID, RecoveryAmount,TranDate)

		return True

def setODRecovery(ID, RecoveryAmount,TranDate):
	try:
		ODWObj 		=	MKT_OVERDRAFT_WRITE_OFF.query.get(ID)
		if ODWObj:
			Audit 			= 	mktaudit.getAuditrail()
			Authorizer 		= 	Audit['Authorizer']
			Authorizeon		= 	Audit['Authorizeon']
			Inputter  		=	ODWObj.Inputter
			Createdon 		=	ODWObj.Createdon
			Branch 			=	ODWObj.Branch
			Account 		=	ODWObj.Account
			Ref 			=	ID
			Note 			=	''
			AccountObj		=	MKT_ACCOUNT.query.get(Account)
			AccountCat 		=	AccountObj.AccCategory	
			Currency 		=	AccountObj.Currency	
			Balance 		=	AccountObj.Balance
			if abs(Balance) < RecoveryAmount:
				flash('Recovery amount cannot greater than account balance')
				return False

			Dict 			= 	getODWriteOffAndRecoveryDict()
			Transaction 	=	Dict.get('RecoveryTran','')
			RecoveryCat 	= 	Dict.get('RecoveryCat','')
			if not RecoveryCat:
				RecoveryCat = mktparam.getPDParam().RecoveryCat

			Overdraft 		= 	mktoverdraft.OVERDRAFT()
			ODWObj.AmountForRecovery -=  RecoveryAmount
			db.session.add(ODWObj)

			SuspendAmount,SuspDrCr,Amount,GL_KEYS,UserRef = Overdraft.checkODAccount(Account,RecoveryAmount,AccountCat,Currency,'Dr',TranDate,Branch)
			CheckAccounting = 	mktteller.setCommitAccouting(Inputter,Createdon,Authorizer,Authorizeon,Branch,Account,AccountCat,Currency,\
								'',RecoveryCat,Currency,RecoveryAmount,'AC',Transaction,TranDate,Ref,Note,Mode='CrDirect',DrGLKey=GL_KEYS,UserReference=ID)
			
			if not CheckAccounting[0]:
				flash(CheckAccounting[1])
				return False

			if SuspendAmount:
				ODSuspendCat 	= 	mktsetting.getAppSetting('ODSuspendCat')

				if ODSuspendCat:
					Overdraft.postSuspendBalance(Branch,Authorizeon, False, AccountCat,Currency, ODSuspendCat, SuspendAmount, TranDate, Transaction, ID, Note, GL_KEYS,UserReference=ID)

			return True

		return False
	except Exception as e:
		raise 

def getODWriteOffAndRecoveryDict():
	try:
		Dict = {} 
		ODWriteOffAndRecovery = mktsetting.getAppSetting('ODWriteOffAndRecovery').splitlines()
		for o in ODWriteOffAndRecovery:
			KeyValue = o.split('*')
			Dict.update({KeyValue[0]:KeyValue[1]})

		return Dict
	except Exception as e:
		raise

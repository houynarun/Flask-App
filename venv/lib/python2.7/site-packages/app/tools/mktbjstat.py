import math
import user 					as mktuser
from datetime 					import date, datetime, timedelta

from blinker 					import signal
from sqlalchemy 				import *

import loantools.nonworkingday 	as mktDay
import mktautoid 				as mktAutoID
import mktdate 					as mktdate
import mktholiday 				as mktHoliday
import mktloan 					as mktloan
import mktmessage 				as mktmessage
import mktpdcollection 			as mktpdcollection

from app.BjStat.models 			import *
from app.BatchJob.models 		import *
from app.mktcore.imports 		import *

import app.tools.mktaudit 		as mktaudit

from .. 						import app
from app.FixedAssetManagement.FixedAsset.models import *



from app.SystemHealthCheck.models 	import *

beforeEOD = signal('before-eod')

afterEOD = signal('after-eod')

class CLS_BATCHJOB(object):
	""" Using for configuration batchjob 
	+ How to runing test :
		$ go-vb
		$ python
		>>> 
			from app.tools.mktbjstat import *
			CLS_BATCHJOB.setup(Description='Clear Notification', Frequency='01M', Tool='Noticication', Order='9', UpOrDown='Down')
	"""

	def __validate__(self,**kwargs):
		Tool = kwargs.get('Tool')
		from app.BatchJob.models import MKT_BATCH_JOB
		BatchJob = MKT_BATCH_JOB.query.filter(MKT_BATCH_JOB.Tool==Tool).first()
		if BatchJob:
			return Exception ('Duplicate batchjob %s. Please running change tool name or check on tool.'%Tool)

	def setup(self,**kwargs):
		from app.BatchJob.models import MKT_BATCH_JOB
		NextRunDate = str(mktdate.getBankDate())
		DateTimeNow = mktdate.getDateTimeNow()
		ID 			= str(self.__getAutoID__())
		# print "self.getAutoID(): ",ID
		Description = kwargs.get('Description')
		Frequency 	= kwargs.get('Frequency')
		Tool 		= kwargs.get('Tool')
		Order 		= kwargs.get('Order')
		UpOrDown 	= kwargs.get('UpOrDown')
		
		self.__validate__()

		OrderObj  	= MKT_BATCH_JOB.query.filter(MKT_BATCH_JOB.Order==Order).first()

		if OrderObj:
			if UpOrDown=="Down":
				Order = int(Order) + 1
				
			BatchObj = MKT_BATCH_JOB.query.all()
			for row in BatchObj:
				if int(row.Order) >= int(Order) and row.ID != '99':
					order = int(row.Order) + 1
					db.session.query(MKT_BATCH_JOB).filter(MKT_BATCH_JOB.ID == row.ID).update({"Order": order })
					db.session.commit()
			# print "A.ID: ",ID
			Dict = {
					'Status':'AUTH',
					'Branch':'HO',
					'Curr':'0',
					'Inputter':'System',
					'Createdon':DateTimeNow,
					'Authorizer':'System',
					'Authorizeon':DateTimeNow,
					'ID':ID,
					'Description':Description,
					'Tool':Tool,
					'JobStatus':'1',
					'Frequency':Frequency,
					'Enable':'Yes',
					'Order':Order,
					'Dependency':'',
					'NextRunDate':NextRunDate
			}

			ObjInsert 	= MKT_BATCH_JOB(**Dict)
			db.session.add(ObjInsert)
			db.session.commit()

		else:
			# if not ObjInsert:
			# print "B.ID: ",ID
			Dict = {
					'Status':'AUTH',
					'Branch':'HO',
					'Curr':'0',
					'Inputter':'System',
					'Createdon':DateTimeNow,
					'Authorizer':'System',
					'Authorizeon':DateTimeNow,
					'ID':ID,
					'Description':Description,
					'Tool':Tool,
					'JobStatus':'1',
					'Frequency':Frequency,
					'Enable':'Yes',
					'Order':Order,
					'Dependency':'',
					'NextRunDate':NextRunDate
			}
			ObjInsert 	= MKT_BATCH_JOB(**Dict)
			db.session.add(ObjInsert)
			print 'Prepare install batchjob...'
			print 'Batch job local provision was install sucessfully.'
			db.session.commit()
			# else:
			# 	print "Object not inserted"


	def removeBatchJob(self,**kwargs):
		""" How to Remove Batch Job
		+ How to runing test :
			$ go-vb
			$ python
			>>> 
				from app.tools.mktbjstat import *
				CLS_BATCHJOB.removeBatchJob(Tool='LocalProvision')
		"""
		from app.BatchJob.models import MKT_BATCH_JOB
		Tool 	= kwargs.get('Tool')
		Order 	= self.__getOrder__(Tool=Tool)
		ID 		= ''
		ID 		= self.__getID__(Tool=Tool)
		# Delete Record
		print "Preparing delete batch job"
		# Move reverse record to history and delete it
		mktaudit.moveAUTHtoHIST(MKT_BATCH_JOB, MKT_BATCH_JOB_HIST, ID)
		# mktaudit.deleteAUTH(MKT_LINE_REPORT_DE, ID)
		db.session.query(MKT_BATCH_JOB).filter(MKT_BATCH_JOB.Tool == Tool).delete()


		# Update Order
		print "Updating order"
		self.__updateOrder__(Order=Order)
		db.session.flush()
		self.__updateID__(ID=ID)
		print "Bach Job removed succesfully"

	def __getAutoID__(self):
		ID = ''
		BatchObj = db.session.query(MKT_BATCH_JOB.ID).filter(~MKT_BATCH_JOB.ID.in_(['99'])).order_by(desc(cast(MKT_BATCH_JOB.ID,Integer))).first()
		ID = int(BatchObj.ID) + 1
		return ID

	def __getOrder__(self,**kwargs):
		Tool  	 = kwargs.get('Tool')
		Order  	 = ''
		BatchObj = db.session.query(MKT_BATCH_JOB.Order).filter(MKT_BATCH_JOB.Tool==Tool).first()
		if BatchObj:
			Order = BatchObj.Order
		return Order

	def __updateOrder__(self,**kwargs):
		Order 	 = kwargs.get('Order')
		BatchJob = MKT_BATCH_JOB.query.filter(cast(MKT_BATCH_JOB.Order, Integer)>Order).all()
		for bj in BatchJob:
			if bj.ID != '99':
				order = int(bj.Order) - 1
				db.session.query(MKT_BATCH_JOB).filter(MKT_BATCH_JOB.ID == bj.ID).update({"Order": order })
				db.session.commit()

	def __updateID__(self,**kwargs):
		ID 	 = kwargs.get('ID')
		newID = ''
		BatchJob = MKT_BATCH_JOB.query.filter(cast(MKT_BATCH_JOB.ID, Integer) >= int(ID)).order_by(asc(cast(MKT_BATCH_JOB.ID, Integer))).all()
		'''
		remove id 2, id 3->2, 4->3, 5->4
		'''
		for bj in BatchJob:
			if bj.ID != '99':
				try:
					newID = int(bj.ID) - 1
					db.session.query(MKT_BATCH_JOB).filter(MKT_BATCH_JOB.ID == bj.ID).update({"ID": newID })
					db.session.commit()
				except Exception as e:
					db.session.rollback()
				raise 

	def __getID__(self,**kwargs):
		ID 			= ''
		Tool 		= kwargs.get('Tool')
		BatchObj 	= MKT_BATCH_JOB.query.filter(MKT_BATCH_JOB.Tool==Tool).first()
		if BatchObj:
			ID 		= BatchObj.ID
		return ID

def getMessageError():
	return "Oop! There is something wrong during EOD. Please check your error log, fix the issue and try again."

def getHolidayList():

	SystemDate 	=	mktdate.getBankDate()
	Holiday 	= 	mktHoliday.getHoliday()
	check 		= 	True
	one_day 	= 	timedelta(days=1) # one day
	StartDate 	= 	datetime.strptime(str(SystemDate),'%Y-%m-%d').date()
	StartDate 	= 	StartDate + one_day
	
	HolidayList	= 	[]

	while check:
		check = mktDay.isNonWorkingDay(StartDate, Holiday)
		if check:
			Item = StartDate
			Item = datetime.strptime(str(Item),'%Y-%m-%d')
			Item = str(Item).split()
			HolidayList.append(str(Item[0]))
			StartDate = StartDate + one_day

	return HolidayList

def setNumOfTransaction(NumOfRecord):
	try:

		Number = float(NumOfRecord) / 1000
		
		if Number < 1:
			return 1
			
		return math.ceil(Number)

	except:
		raise

def getUpdateRecord(NumberOfCompleted, RecordNumber, TotalRecord, NumOfTransaction):
	try:
		
		if int(NumberOfCompleted) == int(NumOfTransaction) or int(RecordNumber) == int(TotalRecord):
			return True

		return False

	except:
		raise

def formatTime(seconds):

	m, s = divmod(seconds, 60)
	h, m = divmod(m, 60)
	
	return "%s:%02d:%02d" % (h, m, s)

def getPercPerTransaction(NumberOfCompleted, TotalRecord):
	try:

		Result = (100 * NumberOfCompleted) / float(TotalRecord)

		return Result

	except:
		raise

def getCountBjStat(JobID, Module, Description, NumberOfRecord, SystemDate, Order, Overide=False):
	try:

		CalendarDate 	= 	mktdate.getDateISO()
		getObj 			=	MKT_BJ_STAT.query.\
							filter(MKT_BJ_STAT.SystemDate == str(SystemDate)).\
							filter(MKT_BJ_STAT.Module == Module).\
							first()

		if not getObj:

			ID  			=	mktAutoID.setAutoID("BJ", 10, "MKT_BJ_STAT")
			# StartTime 		= 	'%s:%s:%s'% (Date.hour, Date.minute, Date.second)
			StartTime 		=	""
			EndTime 		=	""
			Duration 		=	""

			BjStat 	=	MKT_BJ_STAT(
							ID 				=	ID,
							JobID 			=	JobID,
							Module 			=	Module,
							Description 	=	Description,
							StartTime 		=	StartTime,
							EndTime 		=	EndTime,
							Duration 		=	Duration,
							SystemDate 		=	SystemDate,
							CalendarDate 	=	CalendarDate,
							NumberOfRecord 	=	NumberOfRecord,
							Completed 		=	0,
							Order 			=	Order,
							NumberOfCompleted = 0,
							Progress 		=	'N'
						)

			db.session.add(BjStat)
			# print "Inserted."

		elif Overide:
			# # print "Updated."
			getObj.CalendarDate 	=	CalendarDate
			getObj.NumberOfRecord 	=	NumberOfRecord
			# getObj.Completed 		=	0
			# getObj.NumberOfCompleted=	0
			# getObj.Progress 		=	'N'

			db.session.add(getObj)
		
		db.session.commit()

		return True

	except Exception, e:
		db.session.rollback()
		# raise
		return msg_error+"%s"%e

def updateCompletedJobStatus(Tool, TotalRecord, Reference):
	try:
		
		if Reference:
			RecordNumber 		= Reference[0] + 1
			NumberOfCompleted 	= Reference[1] + 1
			NumOfCompletedPerc 	= Reference[2] 
			NumOfTransaction 	= Reference[3] 
			JobID 				= Reference[4]
			
		else:
			JobID 				= ''
			RecordNumber 		= 1
			NumberOfCompleted 	= 1
			NumOfCompletedPerc 	= 0 
			NumOfTransaction 	=	1#setNumOfTransaction(TotalRecord)
			SystemDate 			=	mktdate.getBankDate()
			BatchJob 			= 	MKT_BATCH_JOB.query.filter(MKT_BATCH_JOB.Enable == 'Yes').\
									filter(MKT_BATCH_JOB.Tool == Tool).first()
			
			if BatchJob:
				JobID 	=	BatchJob.ID
				getCountBjStat(BatchJob.ID, BatchJob.ID, BatchJob.Description, TotalRecord, str(SystemDate),BatchJob.Order, True)

		if int(NumberOfCompleted) == int(NumOfTransaction) or int(RecordNumber) == int(TotalRecord):
			NumOfCompletedPerc += float(getPercPerTransaction(NumberOfCompleted, TotalRecord))
			calCompletedPer(JobID, NumberOfCompleted, TotalRecord, NumOfCompletedPerc)
			# NumberOfCompleted = 0

		return [RecordNumber, NumberOfCompleted, NumOfCompletedPerc, NumOfTransaction, JobID]
	
	except Exception as e:
		db.session.rollback()
		raise

def updateNumberOfRecord(Tool,NumberOfRecord, SystemDate):
	try:
		BatchJob 	= 	MKT_BATCH_JOB.query.filter(MKT_BATCH_JOB.Enable == 'Yes').\
						filter(MKT_BATCH_JOB.Tool == Tool).first()
		if BatchJob:
			BjStatObj 	=	MKT_BJ_STAT.query.filter(MKT_BJ_STAT.SystemDate==SystemDate).\
							filter(MKT_BJ_STAT.JobID==BatchJob.ID).first()
			if BjStatObj: 
				BjStatObj.NumberOfRecord =	NumberOfRecord
				db.session.add(BjStatObj)
				db.session.commit()

	except Exception as e:
		db.session.rollback()
		raise

def startRecord():
	try:

		SystemDate 	=	mktdate.getBankDate()
		BatchJob    =   MKT_BATCH_JOB.query.\
						order_by(asc(cast(MKT_BATCH_JOB.Order, Integer))).\
						filter(MKT_BATCH_JOB.NextRunDate == str(SystemDate)).\
						filter(MKT_BATCH_JOB.Enable == 'Yes')
		for j in BatchJob:
			getCountBjStat(j.ID, j.ID, j.Description, 1, str(SystemDate), j.Order)

		if BatchJob.filter(MKT_BATCH_JOB.Tool=='AccrualODAccount').first():
			import app.tools.bank.mktoverdraft as mktoverdraft
			ODCount = mktoverdraft.OVERDRAFT().setAccrODAccount(Counter=True)
			updateNumberOfRecord("AccrualODAccount", ODCount, str(SystemDate))
		
		# Insert Loan Classification BatchJob
		LC_Count = mktpdcollection.loanClassification("", 1, "1", str(SystemDate))
		updateNumberOfRecord("LoanClassification", LC_Count, str(SystemDate))

		# Set number of record
		PD_Count = mktpdcollection.setPDCollection("", 1, "1")
		updateNumberOfRecord("PDCollection", PD_Count, str(SystemDate))

		# Insert Loan Collection BatchJob
		LNC_Count = mktloan.setLoanCollection("", 1, "1", str(SystemDate))
		updateNumberOfRecord("LoanCollection", LNC_Count, str(SystemDate))

		# Insert Accr Account BatchJob
		AC_Count = mktloan.setAccrAccount("","1", str(SystemDate))
		updateNumberOfRecord("AccrualAccount", AC_Count, str(SystemDate))
		
		# Insert Accr Loan BatchJob
		ALC_Count = mktloan.setAccrLoanContract(Stat="1", Date=str(SystemDate))
		updateNumberOfRecord("AccrualLoan", ALC_Count, str(SystemDate))

		# set number of record for loan disbursement
		FirstDate 	=	datetime.strptime(str(SystemDate),'%Y-%m-%d')
		FirstDate 	=	str(FirstDate).split()
		Holiday 	= 	mktHoliday.getHoliday()
		check 		= 	True
		one_day 	= 	timedelta(days=1) # one day
		StartDate 	= 	datetime.strptime(str(SystemDate),'%Y-%m-%d').date()
		StartDate 	= 	StartDate + one_day
		
		HolidayList	= 	[str(FirstDate[0])]

		while check:
			check = mktDay.isNonWorkingDay(StartDate, Holiday)
			if check:
				Item = StartDate
				Item = datetime.strptime(str(Item),'%Y-%m-%d')
				Item = str(Item).split()
				HolidayList.append(str(Item[0]))
				StartDate = StartDate + one_day

		StartDate 	= 	datetime.strptime(str(SystemDate),'%Y-%m-%d').date()
		StartDate 	= 	StartDate + one_day
		DL_Count = mktloan.setLCDisbursement(None, "AUTH", 1, "1", StartDate)
		updateNumberOfRecord("LoanDisbursement", DL_Count, str(SystemDate))

		#Insert Fixed Asset BatchJob
		FAMCount = MKT_ASSET.query.\
				filter(cast(MKT_ASSET.NextRunDate, String) == str(SystemDate)).\
				filter(or_(MKT_ASSET.AssetStatus=='NEW', MKT_ASSET.AssetStatus=='IUS', MKT_ASSET.AssetStatus=='HUP')).\
				all()
		updateNumberOfRecord("FixedAsset", len(FAMCount), str(SystemDate))

		
	except Exception, e:
		db.session.rollback()
		raise
		# return msg_error+"%s"%e

def calCompletedPer(Module, NumberOfCompleted, TotalCount, CompletedPerc, EndRecord=False,EODBankDate=''):
	try:

		SystemDate 		=	mktdate.getBankDate()
		EODBankDate     =  	EODBankDate if EODBankDate else SystemDate
		Date 			= 	datetime.now()
		CurrentTime 	= 	'%s:%s:%s'% (Date.hour, Date.minute, Date.second)
		JobAfterBankDate= 	[]
		BatchJob 		= 	MKT_BATCH_JOB.query.filter(MKT_BATCH_JOB.Tool == 'BankDate').first()
		JobList 		= 	db.session.query(MKT_BATCH_JOB.ID).\
							filter(cast(MKT_BATCH_JOB.Order, Integer) >= int(BatchJob.Order)).all()
		for l in JobList:
			JobAfterBankDate.append(l[0])
		# if Module in ["LD","005","006"]:
		if Module in JobAfterBankDate: 
			if not (EndRecord == False and Module == BatchJob.ID):
				one_day 	= 	timedelta(days=1) # one day
				StartDate 	= 	datetime.strptime(str(SystemDate),'%Y-%m-%d').date()
				StartDate 	= 	StartDate - one_day

				StartDate 	=	str(StartDate).split()
				SystemDate 	=	StartDate[0]
				


		BjStat 	=	MKT_BJ_STAT.query.\
					filter(MKT_BJ_STAT.SystemDate == str(SystemDate)).\
					filter(MKT_BJ_STAT.Module == Module).\
					first()

		if BjStat:
			StartLoop 					=	BjStat.NumberOfCompleted
			# CompletedPerc 				=	(100 * NumberOfCompleted) / float(TotalCount)
			BjStat.NumberOfCompleted 	= 	int(BjStat.NumberOfCompleted) + int(NumberOfCompleted)
			BjStat.Completed 			= 	float(CompletedPerc) + float(BjStat.Completed)
			if float(BjStat.Completed) > 100:
				BjStat.Completed = 100
			NumberOfCompleted 			=	BjStat.NumberOfCompleted

			if int(StartLoop) == 0 and not EndRecord:
				BjStat.StartTime 	= 	CurrentTime

			elif int(NumberOfCompleted) == int(TotalCount) or EndRecord == True:
				BjStat.EndTime 				= 	CurrentTime
				BjStat.CalendarDate 		= 	mktdate.getDateISO()
				BjStat.NumberOfCompleted 	= 	BjStat.NumberOfRecord
				if BjStat.StartTime == '': BjStat.StartTime = CurrentTime 

				t1 = datetime.strptime(str(BjStat.StartTime),'%H:%M:%S')
				t2 = datetime.strptime(str(BjStat.EndTime),'%H:%M:%S')

				delta = (t2 - t1)
				delta = delta.seconds

				BjStat.Duration = 	delta
				File = app.config.get("EOD_LOG_ERROR")

				if EndRecord == True:
					mkttool.setCreateFile(File)
					mkttool.setWriteFile(File,'%s,%s,%s,%s,%s'%(EODBankDate,BjStat.JobID,BjStat.NumberOfRecord,BjStat.Description,formatTime(BjStat.Duration)),Overwirte=False)

			BjStat.Progress 	=	'Y'
			
			db.session.add(BjStat)
			db.session.commit()

		# Clear query object
		del BjStat
		
		return True

	except Exception, e:
		makeLogFileOnError('Y')
		db.session.rollback()
		raise

def makeLogFileOnError(Error):
	try:

		dat 		= datetime.now()
		CurrentTime = '%s:%s:%s'% (dat.hour, dat.minute, dat.second)
		currentDate = '%s-%s-%s'% (dat.year, dat.month, dat.day)
		DateTime 	= str(currentDate) + " " + CurrentTime
		Msg = Error + " " + DateTime

		filename 	= app.config.get("EOD_LOG_RESUME")
		f = open(filename, 'w')
		f.write(Msg)
		f.close()

	except:
		raise

@beforeEOD.connect
def validateEOD(sender, **kwargs):
	"""
	This method created for adding validation when run EOD
	to raise error we have to call method mktmessage.setLogError('error message')
	"""
	try:
		MonthEndProcess = checkManualMonthEndProcess()
		if MonthEndProcess[0] == False:
			mktmessage.setLogError("Accounting Period of Previous Month doesn't close on branch %s. Please go to manual month end closing."%MonthEndProcess[1])

	except Exception, e:
		raise e

def checkManualMonthEndProcess():
	"""
	Check to prevent running Month End when previous month end doesn't process yet.
	Code LockReport 
	100 it means close previos month already
	110 it means dosn't close previos month yet
	111 it means dosn't close previos month and previos year yet
	"""
	try:
		BankDateObj = 	mktdate.getBankDateObj()
		BankDate 	= 	BankDateObj.SystemDate
		EndMonth 	= 	BankDateObj.NextMonthEnd
		OneDay 		= 	timedelta(days=1) # one day
		BankDate 	= 	datetime.strptime(str(BankDate),'%Y-%m-%d').date()
		EndMonth 	= 	datetime.strptime(str(EndMonth),'%Y-%m-%d').date()
		CodeLockReport = "100"

		if BankDate == EndMonth or (BankDate + OneDay) == EndMonth:
			BranchObj 	=	MKT_BRANCH.query.all()
			if BranchObj:
				for row in BranchObj:
					if row.ReportLocked[:3] != CodeLockReport:
						return False, "%s" %(row.ID)
		return True, ''

	except Exception, e:
		print e
		raise e

@beforeEOD.connect
def setSystemHealthCheck(sender, **kwargs):
	BatchJobObj = MKT_BATCH_JOB.query.filter(or_(MKT_BATCH_JOB.ID == "099", MKT_BATCH_JOB.Tool == "SystemHealthCheck")).first()
	SysHealthCheckLog 	= 	db.session.query(MKT_SYSTEM_HEALTH_CHECK).filter(MKT_SYSTEM_HEALTH_CHECK.Level=="Critical").all()	

	if BatchJobObj:
		if BatchJobObj.Enable == "Yes":
			if SysHealthCheckLog:
				Message = "Your system is not healthy. EOD will not be proceeded. Please contact you system administrator."
				mktmessage.setLogError(Message,True)


@beforeEOD.connect
def setSystemOffline(sender, **kwargs):
	mktuser.setSysOffAndOnline()


@afterEOD.connect
def setSystemOnline(sender, **kwargs):
	'''This will get call after running EOD'''
	if kwargs.get('SytemStatus', ''):
		mktuser.setSysOffAndOnline(kwargs['SytemStatus'])
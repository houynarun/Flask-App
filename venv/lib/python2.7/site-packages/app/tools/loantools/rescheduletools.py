from datetime 				import *
from dateutil.relativedelta import *
from flask 					import request, url_for, render_template,flash,redirect
from ... 					import app

from dateutil.relativedelta import relativedelta
from datetime 				import datetime, date, timedelta
from decimal 				import Decimal

from app.LoanProduct.models import MKT_LOAN_PRODUCT
from app.RepaymentSchedule.models import *
from app.ScheduleDefine.models 		import *
from app.HolidayByBranch.models 	import *

import nonworkingday 		as work  #import funtion from nonworking
import app.tools.mktdate 	as mktdate
import app.tools.mktmoney 	as mktmoney
import app.tools.mktsetting as mktsetting
import dateutil 			as dateutil

import calendar
import operator
import math # Round Up in IRR
import time

try:
	import numpy as np # Use for IRR
except Exception, e:
	print "Repayment schedule IRR need install numpy If you want use IRR please type: pip install numpy"

def getFrequencyType(Frequency=''):
	if Frequency:
		if Frequency=='D':
			return 3
		if Frequency=='M':
			return 1
		if Frequency=='Y':
			return 4
		if Frequency=='W':
			return 2

#function check day in a month if out of range in month will be generate last day in a month
def setDayInMonth(StartDate):
	# StartDate = YYYY-MM-DD
	#>> calendar.monthrange(2002,1)
	#>> (1, 31)
	try:
		ConvertToDate=datetime.strptime(str(StartDate),'%Y-%m-%d').date() #Convert string to like this datetime.date(2015, 1, 1)
		return ConvertToDate
	except Exception, e:
		
		StartDate = str(StartDate)
		yy = int(StartDate.split('-')[0])
		mm = int(StartDate.split('-')[1])
		dd = int(StartDate.split("-")[2])
		LastDayInMonth = int(calendar.monthrange(yy,mm)[1])
		YYYYMMDD    = '%s-%s-%s' % (yy,mm,LastDayInMonth)
		NewDate     = datetime.strptime(str(YYYYMMDD),'%Y-%m-%d').date()
		return NewDate

# function generate next month
# auto generate last day in month if out of range in month
def getNextMonth(StartDate,NumberOfNext):
	# Old code
	# ConvertToDate=datetime.strptime(str(StartDate),'%Y-%m-%d').date() #Convert string to like this datetime.date(2015, 1, 1)
	# mm = ConvertToDate.month - 1 + NumberOfNext #Frequency is number of next month
	# yy = ConvertToDate.year + mm / 12
	# mm = mm % 12 + 1
	# dd = min(ConvertToDate.day,calendar.monthrange(yy,mm)[1])
	# YYYYMMDD= '%s-%s-%s' % (yy,mm,dd)
	# NextMonth=datetime.strptime(str(YYYYMMDD),'%Y-%m-%d').date()
	# return NextMonth
	Terms 		= str(NumberOfNext).split('.')
	NumberOfNext 	= int(Terms[0])
	StartDate   = str(StartDate)
	Year        = int(StartDate.split('-')[0])
	Month       = int(StartDate.split('-')[1])
	Day         = int(StartDate.split("-")[2]) 

	mm = Month - 1 + NumberOfNext #Frequency is number of next month
	yy = Year + mm / 12
	mm = mm % 12 + 1
	dd = min(Day,calendar.monthrange(yy,mm)[1])
	YYYYMMDD    = '%s-%s-%s' % (yy,mm,dd)
	NextMonth   = datetime.strptime(str(YYYYMMDD),'%Y-%m-%d').date()
	if len(Terms) == 2:
		Precision 		= Terms[1]
		NextMonth 		= getNextMonthBasePrecision(NextMonth,Precision)
	return NextMonth

#function generate next weekend
def getNextWeek(StartDate,NumberOfNextWeek):

	# ConvertToDate=datetime.strptime(str(StartDate),'%Y-%m-%d').date() #Convert string to like this datetime.date(2015, 1, 1)
	ConvertToDate=setDayInMonth(StartDate)
	Weekend = timedelta(days=7) * NumberOfNextWeek
	NextWeek=ConvertToDate+ Weekend

	return NextWeek

#function generate next day
def getNextDay(StartDate,NumberOfNextDay):
	# NumberOfNextDay is int
	# ConvertToDate=datetime.strptime(str(StartDate),'%Y-%m-%d').date() #Convert string to like this datetime.date(2015, 1, 1)
	ConvertToDate=setDayInMonth(StartDate)
	NumberDay = timedelta(days=NumberOfNextDay)
	NextDay=ConvertToDate + NumberDay
	return NextDay

#function generate next day
def getNextYear(StartDate,NumberOfNextYear):
	# NumberOfNextYear is int
	# ConvertToDate=datetime.strptime(str(StartDate),'%Y-%m-%d').date() #Convert string to like this datetime.date(2015, 1, 1)
	ConvertToDate=setDayInMonth(StartDate)
	NextYear = ConvertToDate + relativedelta(years=NumberOfNextYear)
	return NextYear

#function get collection date check with holiday option
def getColDate(ValueDate,FrequencyType,Frequency,ForwardBackKey,HolidayOption,BaseDateKey="",DayValueDate="", FirstCollection = False, WeekDay ='',NumOfWeek = ''):
	one_day = timedelta(days=1) # one day
	# if BaseDateKey is ValueDate
	# Don't convert Value to datetime Because if day value date can be out of range in month
	# So when use function nextmonth will generate auto last day in month if out of range in month

	if FrequencyType==1: # Frequency by month

		if BaseDateKey==1:
			ValueDate = str(ValueDate)
			ValueDate = '%s-%s-%s'%(ValueDate.split('-')[0],ValueDate.split('-')[1],DayValueDate)
		NextColDate = ValueDate if FirstCollection else getNextMonth(ValueDate,Frequency) #exe function getNextMonth return datetime.date(2015, 1, 1)

		if BaseDateKey==4:
			NextColDate 		= getDayOftheWeek(ValueDate = ValueDate, Days = WeekDay, NumOfWeek = NumOfWeek, isNextMonth = True,Frequency = Frequency)

		tempColDate = NextColDate
		if ForwardBackKey==1: # 1 Move to back day but within a month              
			while work.isNonWorkingDay(NextColDate,HolidayOption)==True:
				NextColDate-= one_day # - 1day
			if NextColDate.month != tempColDate.month: # if move back until within month

				NextColDate=getNextMonth(ValueDate,Frequency) #start calculator NextColDate
				while work.isNonWorkingDay(NextColDate,HolidayOption)==True:
					NextColDate+=one_day # + 1day
					
		elif ForwardBackKey==2: # 2 Move to Forward day but within a month 
			OriginalNextCol = NextColDate
			while work.isNonWorkingDay(NextColDate,HolidayOption)==True: 
				NextColDate+= one_day # + 1day

			if NextColDate.month != tempColDate.month: # if move back until within month
				NextColDate=getNextMonth(ValueDate,Frequency) #start calculator NextColDate

				# Reset Collection Date to original
				NextColDate = OriginalNextCol

				while work.isNonWorkingDay(NextColDate,HolidayOption)==True: 
					NextColDate-=one_day # - 1day
		elif ForwardBackKey == 3: #3 Move to back

			while work.isNonWorkingDay(NextColDate,HolidayOption)==True: 
				NextColDate-= one_day  # - 1day

		elif ForwardBackKey == 4: #4 Move to Forward day

			while work.isNonWorkingDay(NextColDate,HolidayOption)==True: 
				NextColDate+= one_day # + 1day


	elif FrequencyType==2: # 2 Frequency type by weekend

		NextColDate = ValueDate if FirstCollection else getNextWeek(ValueDate,Frequency)#exe function getNextMonth return datetime.date(2015, 1, 1)
		tempColDate = NextColDate

		if ForwardBackKey==1: # 1 Move to back day but within a month              
			
			while work.isNonWorkingDay(NextColDate,HolidayOption)==True:
				NextColDate-= one_day # - 1day

			if NextColDate.month != tempColDate.month:
			# if NextColDate.isocalendar()[1] != tempColDate.isocalendar()[1]: # if move back until within month
				# NextColDate=getNextWeek(NextColDate,Frequency) #start calculator NextColDate

				while work.isNonWorkingDay(tempColDate,HolidayOption)==True:
					tempColDate+=one_day # + 1day
				NextColDate = tempColDate

					
		elif ForwardBackKey==2: # 2 Move to Forward day but within a month 

			while work.isNonWorkingDay(NextColDate,HolidayOption)==True: 
				NextColDate+= one_day # + 1day

			if NextColDate.month != tempColDate.month:
			# if NextColDate.isocalendar()[1] != tempColDate.isocalendar()[1]: # if move back until within month
				# NextColDate=getNextWeek(NextColDate,Frequency) #start calculator NextColDate
				while work.isNonWorkingDay(tempColDate,HolidayOption)==True: 
					tempColDate-=one_day
					# NextColDate-=one_day # - 1day
				NextColDate=tempColDate
					
				

			# Mean that Holiday full one weekend cannot go to next Week and still on Current Value Date
			# or Less then value date ( past date ) so need to move Forward day only
			if str(NextColDate) <= str(ValueDate):
				# NextColDate=getNextWeek(NextColDate,Frequency) #start calculator NextColDate again
				while work.isNonWorkingDay(NextColDate,HolidayOption)==True: 
					NextColDate += one_day # + 1day


		elif ForwardBackKey == 3: #3 Move to back

			while work.isNonWorkingDay(NextColDate,HolidayOption)==True: 
				NextColDate-= one_day  # - 1day
				
			# Mean that Holiday full one weekend cannot go to next Week and still on Current Value Date
			# or Less then value date ( past date ) so need to move Forward day only
			if NextColDate <= ValueDate:
				# NextColDate=getNextWeek(ValueDate,Frequency) #start calculator NextColDate again
				while work.isNonWorkingDay(NextColDate,HolidayOption)==True: 
					NextColDate+= one_day # + 1day

		elif ForwardBackKey == 4: #4 Move to Forward day
			while work.isNonWorkingDay(NextColDate,HolidayOption)==True: 
				NextColDate+= one_day # + 1day
	elif FrequencyType==3: # 3 Frequency type by Day

		NextColDate = getNextDay(ValueDate,Frequency)#exe function getNextDay return datetime.date(2015, 1, 1)
		tempColDate = NextColDate

		if FirstCollection:
			NextColDate = ValueDate

		if ForwardBackKey==1: # 1 Move to back day but within a month              
			
			while work.isNonWorkingDay(NextColDate,HolidayOption)==True:
				NextColDate-= one_day # - 1day
				

			if NextColDate.isocalendar()[1] != tempColDate.isocalendar()[1]: # if move back until within month

				NextColDate=getNextDay(ValueDate,Frequency) #start calculator NextColDate

				while work.isNonWorkingDay(NextColDate,HolidayOption)==True:
					NextColDate+=one_day # + 1day
					
		elif ForwardBackKey==2: # 2 Move to Forward day but within a month 

			while work.isNonWorkingDay(NextColDate,HolidayOption)==True: 
				NextColDate+= one_day # + 1day

			if NextColDate.isocalendar()[1] != tempColDate.isocalendar()[1]: # if move back until within month

				NextColDate=getNextDay(ValueDate,Frequency) #start calculator NextColDate
				
				while work.isNonWorkingDay(NextColDate,HolidayOption)==True: 
					NextColDate-=one_day # - 1day

		elif ForwardBackKey == 3: #3 Move to back

			while work.isNonWorkingDay(NextColDate,HolidayOption)==True: 
				NextColDate-= one_day  # - 1day

		elif ForwardBackKey == 4: #4 Move to Forward day

			while work.isNonWorkingDay(NextColDate,HolidayOption)==True: 
				NextColDate+= one_day # + 1day            

	elif FrequencyType==4: # 4 Frequency type by Yearly

		if BaseDateKey==1:
			ValueDate = str(ValueDate)
			ValueDate = '%s-%s-%s'%(ValueDate.split('-')[0],ValueDate.split('-')[1],DayValueDate)

		NextColDate = getNextYear(ValueDate,Frequency)#exe function getNextYear return datetime.date(2015, 1, 1)
		tempColDate = NextColDate

		if ForwardBackKey==1: # 1 Move to back day but within a month              
			
			while work.isNonWorkingDay(NextColDate,HolidayOption)==True:
				NextColDate-= one_day # - 1day
				

			if NextColDate.isocalendar()[1] != tempColDate.isocalendar()[1]: # if move back until within month

				NextColDate=getNextYear(ValueDate,Frequency) #start calculator NextColDate

				while work.isNonWorkingDay(NextColDate,HolidayOption)==True:
					NextColDate+=one_day # + 1day
					
		elif ForwardBackKey==2: # 2 Move to Forward day but within a month 

			while work.isNonWorkingDay(NextColDate,HolidayOption)==True: 
				NextColDate+= one_day # + 1day

			if NextColDate.isocalendar()[1] != tempColDate.isocalendar()[1]: # if move back until within month

				NextColDate=getNextYear(ValueDate,Frequency) #start calculator NextColDate
				
				while work.isNonWorkingDay(NextColDate,HolidayOption)==True: 
					NextColDate-=one_day # - 1day

		elif ForwardBackKey == 3: #3 Move to back

			while work.isNonWorkingDay(NextColDate,HolidayOption)==True: 
				NextColDate-= one_day  # - 1day

		elif ForwardBackKey == 4: #4 Move to Forward day

			while work.isNonWorkingDay(NextColDate,HolidayOption)==True: 
				NextColDate+= one_day # + 1day 
	return NextColDate   # Finally return Function


def getDayInYear(InterestDayBasis,Date):
	# InterestDayBasis  : 1= 360/360; 2= 365/360; 3=365/365 - 366; 4=365/365 filed must be int
	# Date              : must bedatetime.date(2015, 1, 1)
	"""
		This function use for calculate Total Num. Day in year based on InterestDayBasis
		Parameter:
			InterestDayBasis	(int) : 1= 360/360; 2= 365/360; 3=365/365 - 366; 4=365/365
			Date 				(date): must be datetime.date(2015, 1, 1)

		Example:
			InterestRate = 24 %
			Disbursed 	 = 1500 USD
			ValueDate 	 = 2020-01-15

			No 		CollectionDate 		NumOfDay 	Principal 			Interest 			Total 			LoanBalance
			------------------------------------------------------------------------------------------------------------
			1. 		2020-02-15			xxx			xxx					xxx					xxx				xxx

			Regards to example above, below here is calculation of NumOfDay and Interest based on interest day basis

			* 1 = 360/360 
					- NumOfDay calculation from each installment will be always 30 days even it acutally bigger
					- Interest calculation will be divided with 360 

					=> NumOfDay = 30
					=> Interest = 1500 * 24 / 100 / 360 * 30

			* 2 = 365/360
					- NumOfDay calculation from each installment will be based on actual day calculated
					- Interest calculation will be divided with 360
					
					=> NumOfDay = 31
					=> Interest = 1500 * 24 / 100 / 360 * 31

			* 3 = 365/365-366
					- NumOfDay calculation from each installment will be based on actual day calculated
					- Interest calculation will be divided with 365 in case it non leap year and divided with 366 in case it leap year.

					=> NumOfDay = 31
					=> Interest = 1500 * 24 / 100 / 366 * 31

			* 4 = 365/365 
					- NumOfDay calculation from each installment will be based on actual day calculated
					- Interest calculation will be always divided with 365 even it is leap year.

					=> NumOfDay = 31
					=> Interest = 1500 * 24 / 100 / 365 * 31

	"""

	if InterestDayBasis == 1:
		return float(360)
	elif InterestDayBasis == 2:
		return float(360)
	elif InterestDayBasis == 3:
		if mktdate.isLeapYear(str(Date)):
			# Date is leap 1-29
			return float(366)
		else:
			#year is non leap 1-28
			return float(365)
	elif InterestDayBasis == 4:
		return float(365)


def getNumberOfDay(InterestDayBasis,DateFrom,DateTo):
	# InterestDayBasis  1= 360/360; 2= 365/360; 3=365/365 - 366; 4=365/365
	# DateFrom  : must be is datetime.date(2015, 1, 1)
	# DateTo    : must be is datetime.date(2015, 1, 1)

	if type(DateFrom) is not datetime.date:
		DateFrom=datetime.strptime(str(DateFrom),'%Y-%m-%d').date() #datetime.date(2015, 1, 1)
	if type(DateTo) is not datetime.date:
		DateTo=datetime.strptime(str(DateTo),'%Y-%m-%d').date() #datetime.date(2015, 1, 1)

	# Calculate NumberOfDay if InterestDayBasis 1 = 360/360
	if InterestDayBasis==1: 

		NumberOfDay    =   mktdate.getDatediff360(DateFrom,DateTo)
	else:
		NumberOfDay    =  (DateTo - DateFrom).days

	return NumberOfDay

def getInterestPerYear(RatePerYear,OutstandingAmount):
	# RatePerYear       : Mean that rate per a year. Example : 1% per month = 12% per year
	# OutstandingAmount : Refer to Principal Amount

	InterestPerYear  = OutstandingAmount * RatePerYear / float(100)

	return InterestPerYear

def getInterestPerDay(RatePerYear,OutstandingAmount,InterestDayBasis,Date):
	# RatePerYear       : Mean that rate per a year. Example : 1% per month = 12% per year
	# OutstandingAmount : Refer to Principal Amount
	# InterestDayBasis  : 1= 360/360; 2= 365/360; 3=365/365 - 366; 4=365/365
	# Date              : Refer to date to check DaysInYear must be is datetime.date(2015, 1, 1)

	if type(Date) is not datetime.date:
		Date=datetime.strptime(str(Date),'%Y-%m-%d').date() #datetime.date(2015, 1, 1)

	InterestPerYear     = getInterestPerYear(RatePerYear,OutstandingAmount)
	DaysInYear          = getDayInYear(InterestDayBasis,Date) 
	InterestPerDay      = InterestPerYear / DaysInYear

	# print "CollectionDate:%s"%DateFrom
	# print "Principal:%s"%OutstandingAmount
	# print "InterestPerYear: %s"%InterestPerYear
	# print "InterestPerDay: %s"%InterestPerDay
	# print "DaysInYear:",DaysInYear
	
	return InterestPerDay

def getInterestAmount(RatePerYear,OutstandingAmount,InterestDayBasis,DateFrom,DateTo,NumberOfDay=""):
	# RatePerYear       : Mean that rate per a year. Example : 1% per month = 12% per year
	# OutstandingAmount : Refer to Principal Amount
	# InterestDayBasis  : 1= 360/360; 2= 365/360; 3=365/365 - 366; 4=365/365
	# DateFrom          : Refer to date to check DaysInYear must be is datetime.date(2015, 1, 1)
	# DateTo            : Refer to date to get NumberOfDay must be is datetime.date(2015, 1, 1)
	if type(DateFrom) is not datetime.date:
		DateFrom=datetime.strptime(str(DateFrom),'%Y-%m-%d').date() #datetime.date(2015, 1, 1)
	if type(DateTo) is not datetime.date:
		DateTo=datetime.strptime(str(DateTo),'%Y-%m-%d').date() #datetime.date(2015, 1, 1)

	NumberOfDay         = getNumberOfDay(InterestDayBasis,DateFrom,DateTo) if NumberOfDay == "" else NumberOfDay
	InterestPerDay      = getInterestPerDay(RatePerYear,OutstandingAmount,InterestDayBasis,DateFrom)
	Interest            = InterestPerDay * NumberOfDay
	#print 'NumberOfDay:',NumberOfDay,'InterestPerDay:',InterestPerDay,'Interest:',Interest
	return Interest

def getMaturityDate(ValueDate,FrequencyType,Frequency,Term,FwdBwdKey,HolidayOption,BaseDateKey,FirstDate):
	MaturityDate = None
	CurColDate      = datetime.strptime(str(ValueDate),'%Y-%m-%d').date() #datetime.date(2015, 1, 1)
	BaseValueDate   = datetime.strptime(str(ValueDate),'%Y-%m-%d').date()
	DayValueDate    = str(ValueDate).split("-")[2] # split only date for BaseDateKey is value date
	if FirstDate:
		BaseFirstDate   = datetime.strptime(str(FirstDate),'%Y-%m-%d').date() 
		DayFristDate    = str(FirstDate).split("-")[2] 
	InstallmentNo=1
	while (InstallmentNo <= Term) :

		if BaseDateKey ==1:  # 1 Based on Value day  

			FirstColDate=getColDate(BaseValueDate, #Value date
			FrequencyType,#Frequency Type
			Frequency,#Frequency
			FwdBwdKey,#FwdBwdKey
			HolidayOption,
			BaseDateKey,
			DayValueDate)

		elif BaseDateKey ==2:  # Based On Previous day     

			FirstColDate=getColDate(CurColDate, #Value date
			FrequencyType, #Frequency Type
			Frequency, #Frequency
			FwdBwdKey, #FwdBwdKey
			HolidayOption)

		elif BaseDateKey ==3:  # Based On First Date

			if InstallmentNo == 1:
				FirstColDate=getColDate(BaseFirstDate, #First date
				FrequencyType, #Frequency Type
				Frequency, #Frequency
				FwdBwdKey, #FwdBwdKey
				HolidayOption,
				FirstCollection = True)

			else:

				FirstColDate=getColDate(BaseFirstDate, #First date
				FrequencyType, #Frequency Type
				Frequency, #Frequency
				FwdBwdKey, #FwdBwdKey
				HolidayOption)
		# for generate next collection date
		DateFrom            = CurColDate
		DateTo              = FirstColDate
		if FrequencyType==1:
			
			BaseValueDate = '%s-%s-%s'%(BaseValueDate.year,BaseValueDate.month,DayValueDate)
			BaseValueDate=getNextMonth(BaseValueDate,Frequency)

			 # if BaseDateKey is FirstDate
			if BaseDateKey == 3:
				BaseFirstDate = '%s-%s-%s'%(FirstColDate.year,FirstColDate.month,DayFristDate)

		else:
			BaseValueDate=getNextWeek(BaseValueDate,Frequency)
			if BaseDateKey == 3:
				BaseFirstDate = FirstColDate

		CurColDate 			= FirstColDate
		MaturityDate 		= FirstColDate
		InstallmentNo+=1

	return MaturityDate

'''
		Return the Internal Rate of Return (IRR)
This is the "average" periodically compounded rate of return that 
gives a net present value of 0.0; for a more complete explanation, see Notes below.
Rate in rate per year then the result will be return Rate Per Year
Reference : 
	http://docs.scipy.org/doc/numpy/reference/generated/numpy.irr.html#g32
	https://docs.python.org/2/library/math.html	
'''
def getIRR(DisburseAmount,Rate,FrequencyType,NumberOfInstallment,Frequency=1):
	Month 	= float(12) # Total Month in a year.
	Week 	= float(52) # Total Week in a year.
	Day 	= float(360)

	''' 
		IRRMode in App Setting
		IRRMode = 1 (Mode 1)

			* PaymentAmount Round Up 
				Ex. 47.3 => 48.0
			* IRR Rate decimal point is 2 
				Ex. 21.7823 => 21.78
			* Total Round at last installment

		IRRMode = 2 (Mode 2)
			* PaymentAmount Round Down
				Ex. 47.3 => 47.0
			* IRR Rate decimal point is ALL
				Ex. 21.7823 => 21.7823
			* Total Round at first installment
			* Interest Rate base on actual day

		IRRMode = 3 (Mode 3)
			* PaymentAmount Round Down
				Ex. 47.3 => 47.0
			* IRR Rate decimal point is ALL
				Ex. 21.7823 => 21.7823
			* Total Round at first installment
			* Interest Rate base on 30 days
	'''

	IRRMode = mktsetting.getAppSetting('IRRMode') if mktsetting.getAppSetting('IRRMode') else '1'
	#print "IRRMOde ", IRRMode

	# Calculator Rate refer to frequency type
	if FrequencyType == 1 : # Frequency by month
		# Rate Per Month
		CalRate 	= float(Rate) / Month / float(100)
	
	elif FrequencyType == 2 : # Frequency type by weekend
		# Rate Per Week
		CalRate 	= float(Rate) / Week / float(100) 

	elif FrequencyType == 3:
		CalRate 	= float(Rate) / Day / float(100) 

	# print "CalRate ", CalRate

	# Calculator Total interest  of Loan cycle
	# Total interest is calcuated based on Term, not on installment
	TotalInterest 		= float(DisburseAmount) * float(CalRate) * float(NumberOfInstallment) * (Frequency)

	# Calculator TotalPayment of Loan cycle
	TotalPayment 		= TotalInterest + DisburseAmount

	# Calculator Total Payment Amount Per Installment  
	PaymentAmount 		= float(TotalPayment / NumberOfInstallment)

	if IRRMode == '1':
		# Round Up Total Payment Amount Per Installment	
		# Ex. PaymentAmount = 47.3 => 48.0
		RndPaymentAmount = math.ceil(PaymentAmount) # math.ceil(x) Return the ceiling of x as a float, the smallest integer value greater than or equal to x.
		# RndPaymentAmount = round(PaymentAmount)

	elif IRRMode == '2':
		# Round Down Total Payment Amount Per Installment	
		# Ex. PaymentAmount = 47.3 => 47.0
		RndPaymentAmount = math.floor(PaymentAmount) 

	elif IRRMode == '3':
		RndPaymentAmount = math.floor(PaymentAmount)

	#print "Round PaymentAmount:",RndPaymentAmount	

	DecimalValue,PaymentAmount =  math.modf(PaymentAmount) # math.modf(x) Return the fractional and integer parts of x. Both results carry the sign of x and are floats.
	# print NumberOfInstallment
	# print 'PaymentAmount: ', PaymentAmount

	#Calculate Total Round of each installation
	TotalRound = DecimalValue * NumberOfInstallment

	#FirstPaymentAmount =  math.modf((DecimalValue * NumberOfInstallment)+PaymentAmount)[1]	# old code

	FirstPaymentAmount = TotalRound + PaymentAmount
	# print 'FirstPaymentAmount:',FirstPaymentAmount
	NumOfInstallment = int(NumberOfInstallment - 1)
	ListPaymentAmount 	= [-DisburseAmount]
	ListPaymentAmount.append(FirstPaymentAmount)
	ListInstallmentAmount = [float(PaymentAmount)]*(NumOfInstallment) # -1 Mean that we are append first installment already
	ListPaymentAmount.extend(ListInstallmentAmount)
	# print "ListPaymentAmount",ListPaymentAmount

	'''
				ListPaymentAmount 
	Input cash flows per time period. By convention, net "deposits" are negative and 
	net "withdrawals" are positive. Thus, for example, at least the first element of values,
	which represents the initial investment, will typically be negative.
	Ex : [-1500.0, 153.0, 147.0, 147.0, ...., 147.0]	'''

	if IRRMode == '1':	

		IRR = round(np.irr(ListPaymentAmount), 4) * 100 # multiply by 100 mean that value convert to percentage

	elif IRRMode == '2':

		IRR = round(np.irr(ListPaymentAmount) * 100, 15)
	elif IRRMode == '3':
		IRR = round(np.irr(ListPaymentAmount) * 100, 15)

	IRR = IRR * 12 # multiply by 12 mean that  12 Months/Year then get Rate Per Year

	# print "IRR Rate: ", IRR
	
	# print 'TotalInterest: %s ,TotalPayment: %s'%(TotalInterest,TotalPayment)
	# print 'InstallmentAmount: %s ,Round: %s , IRR RatePerYear:%s'%(PaymentAmount,RndPaymentAmount,IRR)

	return IRR,RndPaymentAmount,TotalRound

'''Declining Mode'''
def getScheduleDeclining(DisburseAmount,ValueDate,Rate,FrequencyType,Frequency,Term,InterestDayBasis,FwdBwdKey,HolidayOption,Currency,BaseDateKey,FrequencyP,
						FrequencyI,RepaymentMode,Locale=None,FirstDate=None,InternalRateReturn=False,PaymentHoliday=None,NumOfHolidayInstallment=None,OptWaiveInterest=False,
						WeekDay=MO,NumOfWeek=1,ParamCharge={},AccrCurrentInt=0,AccrCurrentCharge=0):
	''' 
		IRRMode in App Setting
		IRRMode = 1 (Mode 1)

			* PaymentAmount Round Up 
				Ex. 47.3 => 48.0
			* IRR Rate decimal point is 2 
				Ex. 21.7823 => 21.78
			* Total Round at last installment

		IRRMode = 2 (Mode 2)
			* PaymentAmount Round Down
				Ex. 47.3 => 47.0
			* IRR Rate decimal point is 15
				Ex. 21.7823 => 21.7823
			* Total Round at first installment
	'''

	"""
	Daily Loan	
	======================
		Related Parameter:
			* FrequencyType 	: (int) => 3 #1=Monthly,#2=Weekly,#3=Daily

			* Frequency 	  	: (int) => 1 
										Ex: Frequency = 1 # collect once a day,
											Frequnecy = 2 # collect every 2 days

			* Term	    		: (int) => 12 #For Dialy loan do not need Term(Month) Term here mean installment
										Ex: 12 # 12 installment not 12 day (it could be more than 12 days in case escape holiday)
			
			* BaseDateKey 		: (int) => 1,3 #1=Based on ValueDate, #3=Based on FirstDate (need FirstDate)
										This key work different from Monthly collect. 
										Ex: 3 (FirstDate = 2017-01-01)
											Monthly
												1. 2017-01-01		2. 2017-02-01
											Daily
												1. 2017-01-01 		2. 2017-01-02

			* FirstDate 		: (str) => Required when BaseDateKey=3

			* FwdBwdKey 		: (int) => 4 #4=Always Forward
										This key will forward collect date in case collect date is on holiday
										Work with HolidayOption
			
			* HolidayOption 	: (int) => 1,2,3,4 #1=Sat+Sun+Holiday #2=Sun+Holiday #3=Holiday #4=No Holiday

			* FrequencyP 		: (int) => 1
										Ex: 1 = collect principal once a day
											2 = collect principal every 2 days

			* FrequencyI 		: (int) => 1
										Ex: 1 = collect interest once a day
											2 = collect interest every 2 days
			
			* RepaymentMode 	: (int) => 1,2,3,4 #1=Decline #2=Annunity #3=Flat #4=IRR

		Flow:
			1. Find FirstColDate based on BasedDateKey:
				BasedDateKey : 1 (ValueDate) FirstColDate = Value + 1 day, in case it on holiday will add 1 day until it over holiday
				BasedDateKey : 3 (FirstDate) FirstColDate = FirstDate , in case it on holiday will add 1 day until it over holiday

			2. Calculate Num Day, interest, principal etc is the same as Monthly and Weekly loan based on RepaymentMode (Decline, Annunity, etc.)

	"""
	IRRMode 			= mktsetting.getAppSetting('IRRMode') if mktsetting.getAppSetting('IRRMode') else '1'
	#print "IRRMOde ", IRRMode
	
	# Block IRR Rate
	if InternalRateReturn:
		IRRObj					= getIRR(DisburseAmount,Rate,FrequencyType,Term,Frequency)
		Rate 					= IRRObj[0] # IRR Rate Per Year 
		# Rate 					= 2.45*12 
		PaymentAmount   		= IRRObj[1] # Total Payment Amount Per Installment
		TotalPaymentWithRound   = IRRObj[2] + PaymentAmount

	CurrencyObj 	= 	mktmoney.getCurrencyObj(Currency)
	OriginSmallerRnt = CurrencyObj.SmallestRndTo
	RowRecord 		=	[]
	ColRecord		=	{}
	BalAmount 		= 	float(DisburseAmount) 

	# Rady 20200116- This ID use for round amout of schedule up or down base round option 1, 10, 50, 100, 1000
	SchedSmallestRndTo 	= str(mktsetting.getAppSetting('SCHED_SMALLEST_RNDTO')).split()
	try:
		if SchedSmallestRndTo:
			matching = [item for item in SchedSmallestRndTo if str(Currency) in item]
			# This variable use for get round option of matching: matching = USD50, result of SmallerRnt = 50
			SmallerRnt = matching[0][3:]
			CurrencyObj.SmallestRndTo = int(SmallerRnt)
	except:
		print 'Configuration in app setting with ID SCHED_SMALLEST_RNDTO is wrong %s'%SmallerRnt
		pass

	CurColDate      = datetime.strptime(str(ValueDate),'%Y-%m-%d').date() #datetime.date(2015, 1, 1)
	BaseValueDate   = datetime.strptime(str(ValueDate),'%Y-%m-%d').date()
	DayValueDate    = str(ValueDate).split("-")[2] # split only date for BaseDateKey is value date
	if FirstDate:
		BaseFirstDate   = datetime.strptime(str(FirstDate),'%Y-%m-%d').date() 
		DayFristDate    = str(FirstDate).split("-")[2] 

	# if FirstDate:
	# 	BaseValueDate   = datetime.strptime(str(FirstDate),'%Y-%m-%d').date() 
	# 	DayValueDate    = str(FirstDate).split("-")[2] 

	TempFrequencyP	=	FrequencyP
	CountFrequencyP	=	1
	CountFrequencyI	=	1
	NumberOfDay 	=	0
	TempInterest 	= 	0
	CurInterest 	= 	0
	InterestTaken 	= 	False # This variable define if interest is already taken avoid for retake.
	InstallmentNo 	=	1 
	TotalNumInstallment = Term
	one_day 			= timedelta(days=1)
	while (InstallmentNo <= TotalNumInstallment):

		if BaseDateKey ==1:  # 1 Based on Value day  

			FirstColDate=getColDate(BaseValueDate, #Value date
			FrequencyType,#Frequency Type
			Frequency,#Frequency
			FwdBwdKey,#FwdBwdKey
			HolidayOption,
			BaseDateKey,
			DayValueDate)

		elif BaseDateKey ==2:  # Based On Previous day     

			FirstColDate=getColDate(CurColDate, #Value date
			FrequencyType, #Frequency Type
			Frequency, #Frequency
			FwdBwdKey, #FwdBwdKey
			HolidayOption)

		elif BaseDateKey ==3:  # Based On First Date

			if InstallmentNo == 1:
				#Skip a week in case special holiday in Mynamar
				NextDateWeek = BaseFirstDate
				NextDay = str(NextDateWeek).split("-")[2]

				FirstColDate=getColDate(BaseFirstDate, #First date
				FrequencyType, #Frequency Type
				Frequency, #Frequency
				FwdBwdKey, #FwdBwdKey
				HolidayOption,
				FirstCollection = True)
			else:

				FirstColDate=getColDate(BaseFirstDate, #First date
				FrequencyType, #Frequency Type
				Frequency, #Frequency
				FwdBwdKey, #FwdBwdKey
				HolidayOption)
				#Skip a week in case special holiday in Mynamar
				NextBaseFirstDate = getNextWeek(BaseFirstDate,Frequency)
				HolidayByBranch = getNextSpecialWeek(NextBaseFirstDate,1)
				if HolidayByBranch:
					FirstColDate = getNextWeek(NextBaseFirstDate,1)
					BaseFirstDate = getNextWeek(BaseFirstDate,1)

				if Frequency == 1:
					NextDateWeek = getNextWeek(BaseFirstDate,Frequency)
				else:
					NextDateWeek = getNextWeek(NextDateWeek,Frequency)

				NextDay = str(NextDateWeek).split("-")[2]

		elif BaseDateKey == 4:
			dic 				= {'MO':MO,'TU':TU,'WE':WE,'TH':TH,'FR':FR,'SA':SA,'SU':SU}
			WeekDay 			= WeekDay
			NumOfWeek 			= int(NumOfWeek)
			WeekDays 			= dic[WeekDay]
			FirstCollection 	= False
			FirstColDate 	= getColDate(CurColDate, FrequencyType, Frequency, int(FwdBwdKey), HolidayOption, BaseDateKey, DayValueDate, FirstCollection, WeekDays, NumOfWeek)
		DateFrom            = CurColDate
		DateTo              = FirstColDate
		
		NumberOfDay         = getNumberOfDay(InterestDayBasis,DateFrom,DateTo)

		# Generate Next Col Date Base Frequency Type
		if FrequencyType==1:
			
			BaseValueDate = '%s-%s-%s'%(BaseValueDate.year,BaseValueDate.month,DayValueDate)
			BaseValueDate=getNextMonth(BaseValueDate,Frequency)

			 # if BaseDateKey is FirstDate
			if BaseDateKey == 3:
				BaseFirstDate = '%s-%s-%s'%(FirstColDate.year,FirstColDate.month,DayFristDate)

		elif FrequencyType==2:
			BaseValueDate=getNextWeek(BaseValueDate,Frequency)
			if BaseDateKey == 3:
				if InstallmentNo == 1:
					BaseFirstDate = '%s-%s-%s'%(FirstColDate.year,FirstColDate.month,DayFristDate)
				else:
					BaseFirstDate = '%s-%s-%s'%(NextDateWeek.year,NextDateWeek.month,NextDay)

		elif FrequencyType==3:#loan day
			# BaseValueDate=getNextDay(BaseValueDate,Frequency)
			BaseValueDate=FirstColDate
			if BaseDateKey == 3:
				BaseFirstDate = FirstColDate

		FirstColDateFormat = mktdate.toDateShort(FirstColDate,Locale) if Locale!=None else FirstColDate

		if NumberOfDay == 0:
			CurColDate=FirstColDate
			continue

		OutstandingAmount   = DisburseAmount if RepaymentMode == 3 else BalAmount # if Flat take DisburseAmount
		CurInterest         = getInterestAmount(Rate,OutstandingAmount,InterestDayBasis,DateFrom,DateTo)#Interest
		
		if IRRMode == '3':
			# Calculate Interest with fix number of installment is 30 days.
			NumDay 			= 30
			CurInterest		= getInterestAmount(Rate,OutstandingAmount,InterestDayBasis,DateFrom,DateTo,NumDay)


		#In case loan amendment the current AIR must be add with first interest collection before substrct with prinipal
		#For payment holiday: able to keep to first installment of holiday
		#Update by Mony - 2018-06-11 
		if InstallmentNo == 1:
			if AccrCurrentInt > 0:
				CurInterest+=AccrCurrentInt

		if not InternalRateReturn:
			# Calculate Principal as per FrequencyP setting
			if FrequencyP==1: # 1 Frequency Principal

				# Calculator Term When Using PaymentHoliday 
				# CalTerm working only not paid Principal
				# Then will generate Term again
				if PaymentHoliday in [2,3]: 
					if NumOfHolidayInstallment == Term:
						CalTerm = 1
					else:
						CalTerm = Term - NumOfHolidayInstallment
				else:
					CalTerm = Term

				Principal= DisburseAmount/ float(CalTerm)

			elif TempFrequencyP==CountFrequencyP: # CountFrequencyP Principal >1

				Principal= DisburseAmount/ float(Term) * FrequencyP
				CountFrequencyP=0  # Reset CountFrequency to 0 

			else:
				Principal=0

			# Calculate Interest as per FrequencyI Setting
			if FrequencyI==1:
				
				Interest = CurInterest # InterestPerDay * NumberOfDay 
				InterestTaken = True  # Interest will not be retaken if this variable is true
				if PaymentHoliday:
					if not OptWaiveInterest:
						Interest += TempInterest
						TempInterest = 0

			elif FrequencyI == CountFrequencyI:
				
				TempInterest = TempInterest + CurInterest
				Interest = TempInterest
				TempInterest = 0
				CountFrequencyI = 0
				InterestTaken = True

			else:

				TempInterest = TempInterest + CurInterest
				Interest = 0
				InterestTaken = False

		else:
			# Principal Calculator Base formula IRR	
			CurInterest =   mktmoney.toMoney(CurInterest,CurrencyObj)
			CurInterest = 	float(CurInterest.replace(',',''))
			Principal 	=	PaymentAmount - CurInterest
			Interest 	=	CurInterest

			if IRRMode == '1' :				
				Principal 	=	PaymentAmount - CurInterest

			elif IRRMode == '2' :
				if InstallmentNo == 1 :
					Principal 	=	TotalPaymentWithRound - CurInterest
			
			if PaymentHoliday:
				if not OptWaiveInterest:
					Interest += TempInterest
					TempInterest = 0
		
		#Frequency Principal >1 when last term have balance need Principal = Balance
		if float(InstallmentNo) == float(Term): # for the last of term if Balance less then 0 need Principal= Balance
			Principal 	= BalAmount
			if not InternalRateReturn:
				Interest 	= TempInterest if not InterestTaken else Interest
		
		#Calculator Payment Holiday 
		# print 'PaymentHoliday:',PaymentHoliday
		if PaymentHoliday:
			#The proccess working until previous last Installment
			if InstallmentNo <= NumOfHolidayInstallment and InstallmentNo < Term:

				#Principal Only not Paid Interest
				if PaymentHoliday == 1:
					TempInterest = Interest
					Interest = 0

				#Interest Only not Paid Principal
				elif PaymentHoliday == 2:
					Principal = 0

				#Both Principal and Interest
				elif PaymentHoliday == 3:
					TempInterest = Interest
					Interest = 0
					Principal = 0

			#The proccess working from start to end Installment
			if InstallmentNo <= NumOfHolidayInstallment and InstallmentNo <= Term:
				# Block Waive Interest in last Installment
				if OptWaiveInterest: #Give parameter True system will Waive Interest 
					Interest = 0

		# Block Charge
		ParamCharge.update({'LoanOutstanding':DisburseAmount,
							'LoanBalance':BalAmount,
							'NumberOfDay':NumberOfDay
			})
		# print 'ParamCharge',ParamCharge
		Charge = calculateCharge(**ParamCharge)
		if Charge >= 0:
			Charge =  mktmoney.toMoney(Charge,CurrencyObj)

		#Formatting Currency
		Principal		= mktmoney.toMoney(Principal,CurrencyObj) #format to default #,##0.00
		Interest 		= mktmoney.toMoney(Interest,CurrencyObj)

		#The total amount must be the sum of Principal and Interest after rounding.
		TotalAmount 	= float(Principal.replace(',','')) + float(Interest.replace(',',''))  + float(Charge.replace(',', ''))
		TotalAmount 	= mktmoney.toMoney(TotalAmount,CurrencyObj)

		# No deduction for last installment, it is absolutely Zero.
		BalAmount       = BalAmount - float(Principal.replace(',','')) if InstallmentNo != Term else 0
		BalAmountStr    = mktmoney.toMoney(BalAmount,CurrencyObj)

		ColRecord.update({'InstallmentNo':InstallmentNo})
		ColRecord.update({'CollectionDate':FirstColDate})
		ColRecord.update({'FormatCollectionDate':FirstColDateFormat})
		ColRecord.update({'Principal':Principal})
		ColRecord.update({'Interest':Interest})
		ColRecord.update({'TotalAmount':TotalAmount})
		ColRecord.update({'Balance':BalAmountStr})
		ColRecord.update({'NumberOfDay':NumberOfDay})
		ColRecord.update({'Charge':Charge})

		RowRecord.append(ColRecord)
		ColRecord ={}

		CurColDate=FirstColDate
		InstallmentNo+=1
		CountFrequencyP+=1
		CountFrequencyI+=1

	# set original smaller round to obj currency
	CurrencyObj.SmallestRndTo = OriginSmallerRnt

	return RowRecord  # Finally return funtion

''' Annuity Mode '''
def getScheduleAnnuity(DisburseAmount,ValueDate,Rate,FrequencyType,Frequency,Term,Currency,Locale=None,ParamCharge={},
					   AccrCurrentInt=0,AccrCurrentCharge=0):
	
	CurrencyObj 	= 	mktmoney.getCurrencyObj(Currency)
	OriginSmallerRnt = CurrencyObj.SmallestRndTo
	RowRecord		=	[]
	ColRecord		=	{}
	BalAmount 		=	float(DisburseAmount) 

	CurColDate 		=	datetime.strptime(str(ValueDate),'%Y-%m-%d').date() #datetime.date(2015, 1, 1)
	NumberOfDay 	=	0
	InstallmentNo 	=	1
	CalChargeRate 	= 	0

	# Rady 20200116- This ID use for round amout of schedule up or down base round option 1, 10, 50, 100, 1000
	SchedSmallestRndTo 	= str(mktsetting.getAppSetting('SCHED_SMALLEST_RNDTO')).split()
	try:
		if SchedSmallestRndTo:
			matching = [item for item in SchedSmallestRndTo if str(Currency) in item]
			# This variable use for get round option of matching: matching = USD50, result of SmallerRnt = 50
			SmallerRnt = matching[0][3:]
			CurrencyObj.SmallestRndTo = int(SmallerRnt)
	except:
		print 'Configuration in app setting with ID SCHED_SMALLEST_RNDTO is wrong %s'%SmallerRnt
		pass

	while (InstallmentNo<=Term) :
		CalRate = Rate
		
		# Case Charge using the same interest, We need to add charge rate with interest for cal total amount
		if ParamCharge:
			if ParamCharge.get('Type') == 3:
				CalRate += float(ParamCharge.get('ChargeRate',0))

		if FrequencyType==1:
			FirstColDate 	= getNextMonth(CurColDate,Frequency)
			CalRate  		= CalRate/float(100)/float(12)
			NumberOfDay 	= 30*Frequency
		elif FrequencyType==2:
			FirstColDate 	= getNextWeek(CurColDate,Frequency)
			CalRate  		= CalRate/float(100)/float(12)/float(30)*7
			NumberOfDay 	= 7*Frequency
		elif FrequencyType==3:#loan day			
			FirstColDate 	= getNextDay(CurColDate,Frequency)
			CalRate 		= CalRate/float(100)/float(12)/float(30)
			NumberOfDay 	= 1*Frequency

		CalRate  *= Frequency # Calculate with Frequency

		# CalRate 	 = RateByFreq + CalChargeRate

		# Find Total Payment Per Installment
		# Annuity Formula http://128.199.113.111/root/vb/wikis/Annuity
		TotalAmount     = (CalRate/ (1-(1+CalRate)**(-Term)))*DisburseAmount
		# Round TotalAmount
		TotalAmount     = mktmoney.toMoney(TotalAmount, CurrencyObj)

		# Calculate Interest
		# Interest        = BalAmount * CalRate
		InterestPerDay      = getInterestPerDay(RatePerYear=Rate, OutstandingAmount=BalAmount, InterestDayBasis=1, Date=CurColDate)
		Interest            = InterestPerDay * NumberOfDay
		
		if InstallmentNo == 1:
			if AccrCurrentInt > 0:
				Interest 	+= float(AccrCurrentInt)
		# Round Interest
		Interest        = mktmoney.toMoney(Interest,CurrencyObj)

		# No need to round because TotalAmount and Interest is already round
		Principal       = float(TotalAmount.replace(',', '')) - float(Interest.replace(',',''))

		# Block Charge
		ParamCharge.update({'LoanOutstanding':DisburseAmount,
							'LoanBalance':BalAmount,
							'NumberOfDay':NumberOfDay
			})
		Charge = calculateCharge(**ParamCharge)
		
		if InstallmentNo == 1:
			if AccrCurrentCharge >0:
				Charge 	+= AccrCurrentCharge

		if Charge >= 0:
			Charge =  mktmoney.toMoney(Charge,CurrencyObj)
			# Case Charge using the same interest, We need to subtract with charge than monthly repayment is equal 
			if ParamCharge:
				if ParamCharge.get('Type') == 3:
					Principal -= float(Charge.replace(',', ''))

		# print InstallmentNo,'Charge',Charge
		
		# If Last Installment Take All Pricipal takes All BalAmount
		# To make Sum Principal = Disbursement
		if InstallmentNo==Term:
			Principal = BalAmount

		# No deduction for last installment, it is absolutely Zero.
		BalAmount       = BalAmount - Principal if InstallmentNo != Term else 0

		# No need to round just need to format Number with Currency
		# Example USD 1.50 DecimalPlace = 2 KHR 100 DecimalPlace = 0
		Principal          = mktmoney.formatNumber(Principal, DecimalPlace=CurrencyObj.DecimalPlace)
		if InstallmentNo == Term:
			TotalAmount = float(Principal.replace(',', '')) + float(Interest.replace(',', '')) + float(Charge.replace(',', ''))


		#Formatting Currency
		BalAmountStr       = mktmoney.toMoney(BalAmount,CurrencyObj)
		FirstColDateFormat = mktdate.toDateShort(FirstColDate,Locale) if Locale!=None else FirstColDate

		ColRecord.update({'InstallmentNo':InstallmentNo})
		ColRecord.update({'CollectionDate':FirstColDate})
		ColRecord.update({'FormatCollectionDate':FirstColDateFormat})
		ColRecord.update({'Principal':Principal})
		ColRecord.update({'Interest':Interest})
		ColRecord.update({'TotalAmount':TotalAmount})
		ColRecord.update({'Balance':BalAmountStr})
		ColRecord.update({'NumberOfDay':NumberOfDay})
		ColRecord.update({'Charge':Charge})


		RowRecord.append(ColRecord)
		ColRecord ={}


		CurColDate=FirstColDate
		InstallmentNo+=1

	# set original smaller round to obj currency
	CurrencyObj.SmallestRndTo = OriginSmallerRnt

	return RowRecord # Finally return funtion

'''
	This function is Called when user use 
	AnnuityWithHoliday escaping mode
'''
def getScheduleActualNumDay(DisburseAmount,ValueDate,Rate,FrequencyType,Frequency,Term,InterestDayBasis, 
							FwdBwdKey,RepaymentMode,HolidayOption,Currency,BaseDateKey, AnnuityAmount,Locale=None,
							FirstDate=None,AccrCurrentInt=0, ParamCharge={},AccrCurrentCharge=0,
							PaymentHoliday=None,NumOfHolidayInstallment=None,
							OptWaiveInterest=False,OptPrincipalOnlyFix=False,
							DefaultAnnuityAmount=0):

	CurrencyObj 	= 	mktmoney.getCurrencyObj(Currency)
	OriginSmallerRnt = CurrencyObj.SmallestRndTo
	RowRecord 		=	[]
	ColRecord 		=	{}
	BalAmount 		=	float(DisburseAmount) 

	CurColDate      = datetime.strptime(str(ValueDate),'%Y-%m-%d').date() #datetime.date(2015, 1, 1)
	BaseValueDate   = datetime.strptime(str(ValueDate),'%Y-%m-%d').date()
	DayValueDate    = str(ValueDate).split("-")[2] # split only date for BaseDateKey is value date
	if FirstDate:
		BaseFirstDate   = datetime.strptime(str(FirstDate),'%Y-%m-%d').date() 
		DayFristDate    = str(FirstDate).split("-")[2] 

	NumberOfDay 	=	0
	TempInterest 	= 	0
	CurInterest 	= 	0


	InstallmentNo 	= 	1
	TotalNumInstallment = Term
	LoanBalance 	= 	float(DisburseAmount)

    # Variable declear by Panha
	TempIntHoliday		  = 0 
	TempTotalAmount 	  = 0
	ActualPrincipalAmount = 0  #total actual principal amount in payment holiday period
	DefaultAnnuityAmount  = float(DefaultAnnuityAmount) #store original annuity amount first generate
	DefaultPrincipal 	  = 0  #default principal of each installment after payment holiday period
	#reset AnnuityAmount to zero in case annity amount
	if PaymentHoliday and NumOfHolidayInstallment and DefaultAnnuityAmount == float(AnnuityAmount):		
		AnnuityAmount = 0

	# Rady 20200116- This ID use for round amout of schedule up or down base round option 1, 10, 50, 100, 1000
	SchedSmallestRndTo 	= str(mktsetting.getAppSetting('SCHED_SMALLEST_RNDTO')).split()
	try:
		if SchedSmallestRndTo:
			matching = [item for item in SchedSmallestRndTo if str(Currency) in item]
			# This variable use for get round option of matching: matching = USD50, result of SmallerRnt = 50
			SmallerRnt = matching[0][3:]
			CurrencyObj.SmallestRndTo = int(SmallerRnt)
	except:
		print 'Configuration in app setting with ID SCHED_SMALLEST_RNDTO is wrong %s'%SmallerRnt
		pass

	while (InstallmentNo<=TotalNumInstallment) :
		if BaseDateKey ==1:  # 1 Based on Value day  
			OriBaseFirstDate = getNextWeek(BaseValueDate,1)
			HolidayByBranch = getNextSpecialWeek(OriBaseFirstDate,1)
			if HolidayByBranch and FrequencyType == 2:
				BaseValueDate = getNextWeek(BaseValueDate,1)
				FirstColDate = getNextWeek(OriBaseFirstDate,1)
			else:
				FirstColDate=getColDate(BaseValueDate, #Value date
				FrequencyType,#Frequency Type
				Frequency,#Frequency
				FwdBwdKey,#FwdBwdKey
				HolidayOption,
				BaseDateKey,
				DayValueDate)

		elif BaseDateKey ==2:  # Based On Previous day     

			FirstColDate=getColDate(CurColDate, #Value date
			FrequencyType, #Frequency Type
			Frequency, #Frequency
			FwdBwdKey, #FwdBwdKey
			HolidayOption)

		elif BaseDateKey ==3:  # Based On First Date
			if InstallmentNo == 1:
				FirstColDate=getColDate(BaseFirstDate, #First date
				FrequencyType, #Frequency Type
				Frequency, #Frequency
				FwdBwdKey, #FwdBwdKey
				HolidayOption,
				FirstCollection = True)
				
			else:
				OriBaseFirstDate = getNextWeek(BaseFirstDate,1)
				HolidayByBranch = getNextSpecialWeek(OriBaseFirstDate,1)
				if HolidayByBranch and FrequencyType == 2:
					BaseFirstDate = getNextWeek(BaseFirstDate,1)
					FirstColDate = getNextWeek(OriBaseFirstDate,1)
				else:
					FirstColDate=getColDate(BaseFirstDate, #First date
					FrequencyType, #Frequency Type
					Frequency, #Frequency
					FwdBwdKey, #FwdBwdKey
					HolidayOption)

		DateFrom            = CurColDate
		DateTo              = FirstColDate

		NumberOfDay         = getNumberOfDay(InterestDayBasis,DateFrom,DateTo)
		OutstandingAmount   = DisburseAmount if RepaymentMode == 3 else BalAmount # if Flat take DisburseAmount
		CalRate 			= Rate

		# Case Charge using the same interest, We need to add charge rate with interest for cal total amount
		if ParamCharge:
			if ParamCharge.get('Type') == 3:
				CalRate += float(ParamCharge.get('ChargeRate',0))

		if FrequencyType == 1:
			# Calculate rate per month within one year
			CalRate = CalRate/float(100)/float(12) 
		elif FrequencyType == 2:
			CalRate = CalRate/float(100)/float(12)/float(30)*7
		elif FrequencyType == 3:
			CalRate = CalRate/float(100)/float(12)/float(30)

		CalRate         *=Frequency # Calculate with Frequency

		# Find Total Payment Per Installment
		# Annuity Formula http://128.199.113.111/root/vb/wikis/Annuity	
		# AnnuityAmount is used to overide the TotalAmout
		# to make the last Installment TotalAmount Looks
		# Smaller
		if AnnuityAmount > 0:
			TotalAmount = float(AnnuityAmount)			
		else:
			TotalAmount     = (CalRate/ (1-(1+CalRate)**(-Term)))*DisburseAmount	
			DefaultAnnuityAmount = mktmoney.toMoney(TotalAmount, CurrencyObj)
			DefaultAnnuityAmount = float(str(DefaultAnnuityAmount).replace(",",""))

		#Re-generate annunity amount for payment holiday
		if PaymentHoliday and NumOfHolidayInstallment and InstallmentNo == int(NumOfHolidayInstallment)+1 and DefaultAnnuityAmount == float(AnnuityAmount):			
			TempTerm 				= int(TotalNumInstallment) - (int(NumOfHolidayInstallment))
			TempDisburseAmount 		= DisburseAmount - ActualPrincipalAmount + TempIntHoliday
			TotalAmount     		= (CalRate/ (1-(1+CalRate)**(-TempTerm)))*(TempDisburseAmount)
			AnnuityAmount 			= TotalAmount
			DefaultAnnuityAmount 	= TotalAmount

		TotalAmount     		 = mktmoney.toMoney(TotalAmount, CurrencyObj)
		DefaultAnnuityAmount     = mktmoney.toMoney(DefaultAnnuityAmount, CurrencyObj)
		DefaultAnnuityAmount 	 = float(str(DefaultAnnuityAmount).replace(",",""))

		# Calculate Interest
		Interest         = getInterestAmount(Rate,OutstandingAmount,InterestDayBasis,DateFrom,DateTo)
		DefaultPrincipal = float(str(TotalAmount.replace(",",""))) - Interest	

		#In case loan amendment the current AIR must be add with first interest collection before substrct with prinipal
		#Update by Sovankiry - 23/June 2017 with Ticket #473
		if InstallmentNo == 1:
			if AccrCurrentInt > 0:
				Interest+=AccrCurrentInt
		
		if int(AnnuityAmount)==0:
			AnnuityAmount = float(TotalAmount.replace(',', ''))		

		#When user input the number of payment holiday bigger then total number installment
		if NumOfHolidayInstallment >= TotalNumInstallment:
			if OptWaiveInterest == False:
				NumOfHolidayInstallment=TotalNumInstallment-1
			elif  OptWaiveInterest == True:
				NumOfHolidayInstallment=TotalNumInstallment

		#Blog payment holiday for schedule actual number day
		"""
		PaymentHoliday
			1 : Principal Only
			2 : Interest Only
			3 : Both Principal and Interest
			4 : Principal Only + Fix TotalAmount
		"""

		# PaymentHoliday=1 is payment holiday for principle only
		if (PaymentHoliday == 1 or PaymentHoliday == 4) and NumOfHolidayInstallment >= InstallmentNo and OptWaiveInterest == True:
			# Execute if payment holiday is principle only
			if PaymentHoliday == 1:
				# TempTotalAmount is temporary of total amonut. We want to get equal of amount for payment holiday
				if TempTotalAmount == 0:
					TempTotalAmount = (float(TotalAmount.replace(',', '')) - float(Interest))
				TotalAmount    =	mktmoney.toMoney(TempTotalAmount, CurrencyObj) 
				Interest 	   = 	0
			#Execute if payment holiday is principle only and fix amount
			else:
				Interest 	   = 	0
				TotalAmount    =	mktmoney.toMoney(float(TotalAmount.replace(',', '')) , CurrencyObj) 

			#for sum ActualTotalAmount should get from PaymentHoliday			
			ActualPrincipalAmount   =  float(ActualPrincipalAmount)+float(TotalAmount.replace(",",''))

		elif (PaymentHoliday == 1 or PaymentHoliday == 4) and OptWaiveInterest == False:
			#If customer prepayment before collection date
			if NumOfHolidayInstallment>=InstallmentNo:
				# TempIntHoliday is the temporary interest holidy 
				TempIntHoliday  = 	TempIntHoliday+Interest
				if PaymentHoliday == 1:
					if TempTotalAmount == 0:
						TempTotalAmount = (float(TotalAmount.replace(',', '')) - float(Interest))
					TotalAmount     = 	mktmoney.toMoney(TempTotalAmount, CurrencyObj)
					Interest 		= 	0
				else:
					Interest 		= 	0
					TotalAmount    	=	mktmoney.toMoney(float(TotalAmount.replace(',', '')) , CurrencyObj)

				#for sum ActualTotalAmount should get from PaymentHoliday				
				ActualPrincipalAmount   =  float(ActualPrincipalAmount)+float(TotalAmount.replace(",",''))
			else:
				#When customer input annuity amount
				Interest 	=	TempIntHoliday+Interest
				TempIntHoliday 	=	0

		# PaymentHoliday=2 is payment holiday for interest only
		elif PaymentHoliday == 2 and NumOfHolidayInstallment >= InstallmentNo and OptWaiveInterest == True:
			#Paid interest only. but Waive interest => Total amount = 0
			TotalAmount 	= 	mktmoney.toMoney(0, CurrencyObj)
			Interest 		= 	0

			#for sum ActualTotalAmount should get from PaymentHoliday
			ActualPrincipalAmount   =  0

		elif PaymentHoliday == 2 and NumOfHolidayInstallment >= InstallmentNo and OptWaiveInterest == False:
			#Paid interest only
			TotalAmount     = 	mktmoney.toMoney(Interest, CurrencyObj)
			ActualPrincipalAmount   =  0

		#PaymentHoliday=3 is both of payment holiday (principle and interest)
		elif PaymentHoliday == 3 and NumOfHolidayInstallment >= InstallmentNo and OptWaiveInterest == True:
			TotalAmount 	= 	mktmoney.toMoney(0, CurrencyObj)
			Interest 		= 	0
			#for sum ActualTotalAmount should get from PaymentHoliday
			ActualPrincipalAmount   =  0

		elif PaymentHoliday == 3 and OptWaiveInterest == False:
			#If customer prepayment before collection date
			if NumOfHolidayInstallment>=InstallmentNo:
				TotalAmount 	= 	mktmoney.toMoney(0, CurrencyObj)
				TempIntHoliday  = 	TempIntHoliday+Interest
				Interest 		= 	0	
				#for sum ActualTotalAmount should get from PaymentHoliday	
				ActualPrincipalAmount   =  0
			else:				
				Interest 		=	TempIntHoliday+Interest
				TempIntHoliday 	=	0

		#Re-generate annunity amount for payment holiday in case principal is negative
		if PaymentHoliday:

			if float(str(mktmoney.toMoney(Interest,CurrencyObj)).replace(",","")) > float(str(TotalAmount).replace(",","")):
				TotalAmount 			= mktmoney.toMoney(Interest,CurrencyObj)
				TempTerm 				= int(TotalNumInstallment) - (int(NumOfHolidayInstallment))
				TempDisburseAmount 		= LoanBalance + DefaultPrincipal
				AnnuityAmount 			= (CalRate/ (1-(1+CalRate)**(-TempTerm)))*(TempDisburseAmount)
				AnnuityAmount 			= mktmoney.toMoney(AnnuityAmount,CurrencyObj)
				AnnuityAmount 			= float(str(AnnuityAmount).replace(",",""))
				DefaultAnnuityAmount 	= AnnuityAmount		

		#End blog payment holiday for schedule actual number day

		# Round Interest
		Interest        = mktmoney.toMoney(Interest,CurrencyObj)

		# No need to round because TotalAmount and Interest is already round
		Principal       = float(TotalAmount.replace(',', '')) - float(Interest.replace(',', ''))

		# Block Charge
		ParamCharge.update({'LoanOutstanding':DisburseAmount,
							'LoanBalance':BalAmount,
							'NumberOfDay':NumberOfDay
			})
		Charge = calculateCharge(**ParamCharge)

		if InstallmentNo == 1:
			if AccrCurrentCharge >0:
				Charge 	+= AccrCurrentCharge

		if Charge >= 0:
			Charge =  mktmoney.toMoney(Charge,CurrencyObj)
			# Case Charge using the same interest, We need to subtract with charge than monthly repayment is equal
			if ParamCharge:
				if ParamCharge.get('Type') == 3:
					Principal -= float(Charge.replace(',', ''))

		# If Last Installment Take All Pricipal takes All BalAmount
		# To make Sum Principal = Disbursement
		if InstallmentNo == TotalNumInstallment:
			Principal = BalAmount

		# No deduction for last installment, it is absolutely Zero.
		# BalAmount       = BalAmount if (BalAmount - Principal) < 0 else BalAmount - Principal
		LoanBalance 	= BalAmount
		BalAmount       = BalAmount - Principal if InstallmentNo != Term else 0

		# check if balance is negative or zero for reduce installment
		if float(BalAmount) <= float(0):
			BalAmount 	= 0
			# TotalAmount = LoanBalance			
			Principal   = float(LoanBalance)
			if TempIntHoliday>0:
				Interest        = mktmoney.toMoney(TempIntHoliday,CurrencyObj)





		# No need to round just need to format Number with Currency
		# Example USD 1.50 DecimalPlace = 2 KHR 100 DecimalPlace = 0
		Principal          = mktmoney.formatNumber(Principal, DecimalPlace=CurrencyObj.DecimalPlace)
		if InstallmentNo == TotalNumInstallment:
			TotalAmount = float(Principal.replace(',', '')) + float(Interest.replace(',', '')) + float(Charge.replace(',', ''))
			
		# Generate Next Col Date Base Frequency Type
		if FrequencyType==1:
			
			BaseValueDate = '%s-%s-%s'%(BaseValueDate.year,BaseValueDate.month,DayValueDate)
			BaseValueDate=getNextMonth(BaseValueDate,Frequency)

			 # if BaseDateKey is FirstDate
			if BaseDateKey == 3:
				BaseFirstDate = '%s-%s-%s'%(FirstColDate.year,FirstColDate.month,DayFristDate)

		elif FrequencyType==2:

			BaseValueDate=getNextWeek(BaseValueDate,Frequency)

			if BaseDateKey == 3:

				if not InstallmentNo == 1:
					BaseFirstDate = getNextWeek(BaseFirstDate,Frequency)

		elif FrequencyType==3:#loan day
			# BaseValueDate=getNextDay(BaseValueDate,Frequency)
			BaseValueDate=FirstColDate
			if BaseDateKey == 3:
				BaseFirstDate = FirstColDate

		#Formatting Currency
		BalAmountStr       = mktmoney.toMoney(BalAmount,CurrencyObj)
		FirstColDateFormat = mktdate.toDateShort(FirstColDate,Locale) if Locale!=None else FirstColDate
		

		ColRecord.update({'InstallmentNo':InstallmentNo})
		ColRecord.update({'CollectionDate':FirstColDate})
		ColRecord.update({'FormatCollectionDate':FirstColDateFormat})
		ColRecord.update({'Principal':Principal})
		ColRecord.update({'Interest':Interest})
		ColRecord.update({'Charge':Charge})
		ColRecord.update({'TotalAmount':TotalAmount})
		ColRecord.update({'Balance':BalAmountStr})
		ColRecord.update({'NumberOfDay':NumberOfDay})
		#2018-07-13 payment-holiday
		ColRecord.update({'AnnuityAmount':AnnuityAmount})
		ColRecord.update({'DefaultAnnuityAmount':DefaultAnnuityAmount})
		#end
		RowRecord.append(ColRecord)
		ColRecord ={}


		CurColDate=FirstColDate
		InstallmentNo+=1

		#break loop of installment if balance is negative or zero
		if float(BalAmount) <= float(0):
			break
	# set original smaller round to obj currency
	CurrencyObj.SmallestRndTo = OriginSmallerRnt

	return RowRecord # Finally return funtion


def getRepaymentDeclining(Principal = 0, Interest = 0, Tenor = 0, LoanProduct = '', AppDate = '', NumOfDay = 30):
	"""
		Calculate first total monthly payment by FixedPrincipal
		(Declining method)
		Formular: (Principal*InterestPerDay*NumOfDay)+(Principal/Tenor)
		*Tenor = Installment
	"""
	try:
		Principal 		= float(Principal)
		Interest 		= float(Interest)
		Tenor 			= int(Tenor) # already calculated with frequency and frequency type
		InterestPerDay 	= 0
		MonthlyPrincipal= 0
		MonthlyInterest = 0
		Payment 		= 0

		LoanProductObj 	= MKT_LOAN_PRODUCT.query.get(LoanProduct)
		if LoanProductObj:
			IntDayBasis = LoanProductObj.IntDayBasis
			IntDayBasis = int(IntDayBasis)
			InterestPerDay = getInterestPerDay(Interest, Principal, IntDayBasis, AppDate)

			if Tenor:
				MonthlyPrincipal= Principal / Tenor
			MonthlyInterest = InterestPerDay * NumOfDay

			Payment = MonthlyPrincipal + MonthlyInterest

		return Payment
	except Exception as e:
		raise

	return Payment

def getRepaymentAnnuity(Principal = 0, Interest = 0, Tenor = 0):
	"""
		Calculate first total monthly payment by Equated Monthly Installment
		(Anuity method)
		Formular: ((Principal*InterestRate) * (1+InterestRate)^Tenor) / ((1+Interestrate)^Tenor - 1)
		*Tenor = Term
	"""
	try:
		Principal 	= float(Principal)
		Interest 	= (float(Interest) /100) /12
		Tenor 		= int(Tenor)
		Payment 	= ((Principal * Interest) * (1+Interest)**Tenor) / ((1+Interest)**Tenor - 1)
	except Exception as e:
		raise
	
	return Payment

def getChargeAmountPerDay(LoanBalance, ChargeRate):
	""" Calculate Charge Per Day Base on loan balance """
	ChargePerYear = (LoanBalance * ChargeRate ) /float(100)
	ChargePerDay  = ChargePerYear / float(360) 
	return ChargePerDay


def calculateCharge(**kwargs):
	""" Calculate Charge amount base on setting
	Type :	('1', 'Fixed Amount'),
			('2', 'Percentage of Outstanding'),
			('3', 'Rate Base'),
			('4', 'Percentage of Disbursement'),
			('5', 'Percentage of Approval amount'),
			('6', 'Percentage of Loan Balance'),
			('99','CUSTOM')

	Notes: When you are write in 99-CUSTOM please return value by float and rounding

	+  How to use 
	Example 1: Type 1-Fix Amount
	$ go-vb
	$ python
	>>from app.tools.loantools.rescheduletools import calculateCharge
	>>calculateCharge(Type=1, FixAmount=50)
	50.0
	
	Example 2:Type 2-Percentage of Outstanding
	$ go-vb
	$ python
	>>from app.tools.loantools.rescheduletools import calculateCharge
	>>calculateCharge(Type=2, LoanOutstanding=1000, Percentage=2) #Percentage 2%
	20.0

	Example 3:Type 3-Rate Base
	$ go-vb
	$ python
	>>from app.tools.loantools.rescheduletools import calculateCharge
	>>calculateCharge(Type=3, LoanBalance=1000, ChargeRate=10, NumberOfDay=30) #ChargeRate Per Year 10%
	8.333333333333334

	Example 4:Type 4-Percentage of Disbursement
	$ go-vb
	$ python
	>>from app.tools.loantools.rescheduletools import calculateCharge
	>>calculateCharge(Type=4, DisburseAmount=1000, Percentage=4) #Percentage 4%
	40.0

	Example 5:Type 5-Percentage of Approval amount
	$ go-vb
	$ python
	>>from app.tools.loantools.rescheduletools import calculateCharge
	>>calculateCharge(Type=5, ApprovedAmount=1000, Percentage=8) #Percentage 8%
	80.0

	Example 6:Type 6-Percentage of Loan balance
	$ go-vb
	$ python
	>>from app.tools.loantools.rescheduletools import calculateCharge
	>>calculateCharge(Type=6, LoanBalance=1000, Percentage=8) #Percentage 8%
	80.0

	"""
	Type 	= kwargs['Type'] if 'Type' in kwargs else 0
	
	#Calculate Charge by Fix Amount
	if Type == 1:
		return float(kwargs.get('FixAmount'))

	#Calculate Charge Percentage of loan outstanding
	elif Type == 2:
		Charge = float(kwargs.get('LoanOutstanding')) * float(kwargs.get('Percentage')) / float(100)
		return Charge

	#Calculate the same interest
	#Actual Number Of Day
	elif Type == 3:
		ChargePerDay = getChargeAmountPerDay(float(kwargs.get('LoanBalance')), float(kwargs.get('ChargeRate')))
		Charge = ChargePerDay * float(kwargs.get('NumberOfDay'))
		return Charge

	#: Calculate Charge Percentage of loan disbursement
	elif Type == 4:
		Charge = float(kwargs.get('DisburseAmount')) * float(kwargs.get('Percentage')) / float(100)
		return Charge
	
	#: Calculate Charge Percentage of loan approved amount
	elif Type == 5:
		Charge = float(kwargs.get('ApprovedAmount')) * float(kwargs.get('Percentage')) / float(100)
		return Charge

	#: Calculate Charge Percentage of loan balance
	elif Type == 6:
		Charge = float(kwargs.get('LoanBalance')) * float(kwargs.get('Percentage')) / float(100)
		return Charge

	#: Call Custom
	elif Type == 99:
		try:
			""" 
				Dynamic import * from local project
				Process:
					1. Import from local project first
			"""
			ExtendModuleObj = mktsetting.ExtendModule()
			LocalPath 		= ExtendModuleObj.getLocalPath()
			CheckFile 		= ExtendModuleObj.isFileInLocal(FileName='tools/mktcustomscript.py')

			if LocalPath and CheckFile:
				ImportFile = "import %s.tools.mktcustomscript as CustomTool" % LocalPath
				exec(ImportFile)

		except Exception as e:
			raise
		try:
			Charge = str(CustomTool.getCustomCalCharge(**kwargs))
			Charge = float(Charge)
			return Charge
		except NameError as e:
			print 'Error',e
			if str(e) == "global name 'CustomTool' is not defined":
				raise Exception('Couldnot find file mktcustomscript.py in local project for CUSTOM charge.')
	return 0

def getDayOftheWeek(**kwargs):
	"""
	Method use for get days of the week base on:
		* week day[MO, TU, WE, TH, FR, SA, SU] 
		* number of week (1, 2, 3, 4, 'FIRST', 'LAST')

	Args:
		valuedate 	(String) 		: date (YYYY-MM-DD)
		days 		(dateutil) 		: days (MO, TU, WE, TH, FR, SA, SA)
		NumOfWeek 	(Int) 			: Number of the week of months (1, 2, 3, 4)
		isNextMonth (Boolean) 		: True: get next month, False: get current month
		Frequency 	(Int) 			: Frequency (1,2,3,4,5)

	Returns:
		resuslt 					: date (YYYY-MM-DD)

	Examples:
		Here is some sample call function getDayOftheWeek:
		Current Date: 2018-01-01

		>>> print getDayOftheWeek('2018-01-01',MO,3,Flase,1)
		2018-01-15
		>>> print getDayOftheWeek('2018-01-01',MO,3,True,1)
		2018-01-19
	"""
	ValueDate 	= kwargs.get('ValueDate')
	Days 		= kwargs.get('Days','')
	NumOfWeek 	= kwargs.get('NumOfWeek','')
	isNextMonth = kwargs.get('isNextMonth',False)
	Frequency 	= kwargs.get('Frequency',1)
	Year, Month, Day 	= (int(x) for x in str(ValueDate).split('-'))
	Result 	= ""
	if isNextMonth:
		if Month < 12:
			Month = Month - 1 + int(Frequency)
			Year = Year + Month / 12
			Month = Month % 12 + 1
		else:
			Month = int(Frequency)
			Year += 1

	ans 					= datetime(Year, Month, 1)
	if ans:
		Result = datetime.date(ans+relativedelta(weekday=Days (+NumOfWeek)))
		BackMonth = str(Result).split('-')[1]
		if int(Month) < int(BackMonth):
			Result = datetime.date(ans+relativedelta(weekday = Days (+4)))
		if int(Month) == 12 and int(BackMonth) == 1:
			ans 					= datetime(Year, 12, 1)
			Result = datetime.date(ans+relativedelta(weekday = Days (+4)))
	return Result

def getWeekofMonth(year, month, day):
	x = np.array(calendar.monthcalendar(year, month))
	week_of_month = np.where(x==day)[0][0] + 1
	return week_of_month

def getWeekDay(year,month,day):
	WeekDay 	= datetime(year, month, day).strftime("%a").upper()[:2]
	return WeekDay

def getInterestPerDayTemplateBase(SystemDate,LcID):
	InterestPerDay = 0

	RepScheduleObj = MKT_REP_SCHEDULE.query.filter(MKT_REP_SCHEDULE.LoanID == LcID).\
											filter(MKT_REP_SCHEDULE.CollectionDate > str(SystemDate)).\
											order_by(MKT_REP_SCHEDULE.CollectionDate).first()

	if RepScheduleObj:
		InterestPerDay = float(RepScheduleObj.Interest)/int(RepScheduleObj.NumDay)

	return InterestPerDay

def getNextMonthBasePrecision(NextMonth,Precision):

	DateSplit 		= str(NextMonth).split('-')
	yy 				= int(DateSplit[0])
	mm 				= int(DateSplit[1])
	dd 				= calendar.monthrange(eval('%s'%yy),eval('%s'%mm))[1]
	PrecisionDay 	= math.ceil(float('0.'+Precision) * int(dd))
	result 			= NextMonth + timedelta(days=PrecisionDay)

	return result

# This function specific only Mifida Holiday on April skip one week
def getNextSpecialWeek(ValueDate,Frequency):
	resuslt = False
	NextColDate = datetime.strptime(str(ValueDate),'%Y-%m-%d').date() 
	LocationSetting 	= mktsetting.getAppSetting('LOCAL_REGISTER_PATH')
	if NextColDate.month == 4:
		if LocationSetting == 'local.DO' and work.isHolidayByBranch(NextColDate) == True:
			resuslt = True
	return resuslt

from app.mktcore.wtfimports import *
from app.mktcore.imports 	import *
from .models import *
import time
from decimal import *

import app.tools.mktaccount 	as mktaccount
import app.tools.mktparam   	as mktparam
import app.tools.mktdate 		as mktdate
import app.tools.mktmoney 		as mktmoney
import app.tools.mktaccounting 	as mktaccounting
import app.tools.mktteller 		as mktteller
import app.tools.user 			as mktuser
import app.tools.mktaudit 		as mktaudit
import app.tools.mktfundtransfer 	as mktfundtransfer

from app.Account.models 	import *
from app.TellerParam.models import *
from app.CashAccount.models import *

def loadTran():
	Param = mktparam.getTellerParam()
	TranID=''
	if Param:
		TranID = Param.OpenTillTran
		
	return TranID

def loadCashAccount():
	CashAccount 	= ""
	UserObj = mktuser.getUser()
	if UserObj:
		CashAccount = UserObj.CashAccount

	return CashAccount

def loadAccount():
	result 	= []
	Branch 	= mktuser.getCurrentBranch()
	Param 	= mktparam.getTellerParam()
	if Param:		
		row=MKT_ACCOUNT.query.filter_by(Branch=Branch,AccCategory=Param.TillCategory).\
							order_by(MKT_ACCOUNT.ID.asc()).\
							all()
		if row:
			result=row
	return result

@app.route("/Morakot/TillOperationAcc", methods=['GET'])
@checkLogOutSession
@checkLogOutTime
def getTillOperationAcc():

	TillAccount = request.args.get('TillAccount')
	Balance 	= ""
	Currency 	= ""
	Category 	= ""
	# app.logger.debug(TillAccount)
	if TillAccount:
		
		query = MKT_ACCOUNT.query.get(TillAccount)
		if query:
			Category 	= query.AccCategory
			Currency 	= query.Currency
			CurrencyObj = mktmoney.getCurrencyObj(Currency)
			Balance 	= mktmoney.toMoney(float(query.Balance),CurrencyObj)
			# Balance 	= float(query.Balance)

	return jsonify(Balance=Balance,Currency=Currency,Category=Category)


def loadCurrentDate():
	return 	mktdate.getBankDate()

class FRM_TILL_OPEN(exform):
	
	CashID 	= TextField("Cash ID",default=loadCashAccount)
	Operation 	= TextField("Operation ",default='O')
	Transaction = TextField(requiredlabel("Transaction","*"),
							validators=[validators.Required()],
							default=loadTran)
	TranDate   	= DateField(requiredlabel("Transaction Date", "*"), 
							validators=[validators.Required()],
							default=loadCurrentDate)
	Reference 	= TextField(getLanguage("Reference"),[validators.Length( max=35)])
	Note 		= TextAreaField(requiredlabel("Note", "*"),[validators.Length(max=50),validators.Required()])

	TillAccount = QuerySelectField(requiredlabel('Till Account', "*"),
							[validators.Required()],
							query_factory=loadAccount, 
							get_label=lambda a: a.ID + " - " + a.AccName,
							allow_blank=True,
							blank_text='--None--',
							default='--None--',
							description="1-DETAILS")
	Category 	= TextField("Category",description="1-DETAILS")
	Currency 	= TextField("Currency",description="1-DETAILS")
	Balance 	= TextField("Balance",description="1-DETAILS")
	Amount 		= TextField(requiredlabel("Amount","*"),
							validators=[validators.Required()],
							default=0,
							description="1-DETAILS")

	def validate_TranDate(form, field):

		TranDate 	= form.TranDate.data
		try:
			TranDate = datetime.strptime(str(TranDate),'%Y-%m-%d').date()

		except:
			raise ValidationError("This field must be in date format.")

		Check = mktfundtransfer.checkPreMonthDateTransaction(TranDate)
		if Check:
			raise ValidationError(Check)

	def validate_TillAccount(form,field):

		if form.TillAccount.data == '' :
			raise ValidationError("Please selecte Till Account!")

		TillAccount = []
		controls_list 	= request.form
		ListTillAcc		= [item for item in controls_list if "TillAccount" in item]
		ListTillAcc.sort()
		TotalTillAcc=len(ListTillAcc)

		for nub in range(0,TotalTillAcc):
			TillAccount.append(request.form[ListTillAcc[nub]])

		DuplicateAcc   = [x for x in TillAccount if TillAccount.count(x) > 1]
		if DuplicateAcc:
			raise ValidationError("Can not selecte the same account#%s"%DuplicateAcc[0])

	def validate_CashID(form, field):
		if form.CashID.data =='':
			raise ValidationError("Your user don't have vault account!")

	def validate_Amount(form, field):

		VaultAccountObj = []
		dic 		= {}
		ListCurAmo  = []
		TillAccount = ''
		Currency    = ''

		AccObj 			= MKT_ACCOUNT.query
		controls_list 	= request.form
		ListTillAcc		= [item for item in controls_list if "TillAccount" 	in item]
		ListCurrency 	= [item for item in controls_list if "Currency"    	in item]
		ListAmount 		= [item for item in controls_list if "Amount" 		in item]
		

		ListTillAcc.sort()
		ListCurrency.sort()
		ListAmount.sort()

		TotalTillAcc=len(ListTillAcc)
		for nub in range(0,TotalTillAcc):

			TillAccount 	= str(request.form[ListTillAcc[nub]])
			Currency 		= str(request.form[ListCurrency[nub]])
			Amount 			= str(request.form[ListAmount[nub]])
			Amo 			= Amount.replace(',','')
			
			# Sum Total Amount by Currency
			if Currency in dic: 
				TotalAmount = dic[Currency]
				TotalAmount = float(Amo)+TotalAmount
				dic.update({Currency:TotalAmount})
			else:
				dic.update({Currency:float(Amo)})
			
			VaultAccountObj   = mktuser.getVaultInfo(Currency)
			if VaultAccountObj:

				FilterTillAcc = AccObj.get(TillAccount)
				if FilterTillAcc:
					BranchTill 	= FilterTillAcc.Branch
					BranchVault = VaultAccountObj.Branch
					if BranchVault != BranchTill:

						raise ValidationError("Difference between branch Vault and Till.")

				CheckBalance2 = mktaccounting.checkMaxMinBalance(TillAccount, Currency, Decimal(Amo), "Dr")
				if CheckBalance2:
					raise ValidationError(CheckBalance2)

				CheckBalance1 = mktaccounting.checkMaxMinBalance(VaultAccountObj.ID,VaultAccountObj.Currency, Decimal(Amo), "Cr")
				if CheckBalance1:
					raise ValidationError(CheckBalance1)
			else:
				raise ValidationError("Your user don't have vault account in currency%s"%Currency)

		#Check Total Balance by Currency
		ListCurrencyInDic = list(dic.keys())
		for item in ListCurrencyInDic:
			AccVault = mktuser.getVaultInfo(item)

			if AccVault.Balance < dic[item]:
				raise ValidationError("Total amount in %s currency doesn't have sufficient fund. Current balance is %s" %(item,float(AccVault.Balance)))
			
	@staticmethod
	def beforeNewID ():
		Check = mktteller.isUserVaultAccount()
		if not Check[0]:
			return True,Check[1]
		else:
			#Mean that user have cash account.
			return False,''

	@staticmethod
	def moneyField():
		return [["Amount","Currency"],["Balance","Currency"]]

	@staticmethod
	def setWidth():
		control_list = [('Operation',len2),('Transaction',len2),
						('TranDate',len3),('Currency',len1),
						('CashID',len2),('Category',len1)]

		return control_list

	@staticmethod
	def listField():

		Fields = ["ID", "CashID","Transaction", "TranDate", "Reference", "Note"]

		return Fields, ["Operation*EQ*O"]

	@staticmethod
	def setVisible():
		control_list=['Operation','Transaction','Category']
		return control_list

	@staticmethod
	def setDisable():
		controls_list=["CashID" ,"Transaction","TranDate","Balance","Category","Currency","Operation"]
		return controls_list

	@staticmethod
	def isMultiValue():
		controls_list=["1-DETAILS"]
		return controls_list

	@staticmethod
	def hotField():
		hotfield = []

		fielddisplay = "$('#Balance').val(data.Balance);$('#Currency').val(data.Currency);$('#Category').val(data.Category)" 
		varname = "TillAccount:$('#TillAccount').val()"
		fun = ["TillAccount", varname, fielddisplay, "/Morakot/TillOperationAcc", "click"]
		hotfield.append(fun)

		return hotfield
		
	@staticmethod
	def formReadOnly():
		return "AUTH"
		
	@staticmethod
	def findinHist():
		return True

	@staticmethod
	def beforeInsert():
		# print g.formID
		AuthLevel 	= g.getNAuthorize
		# print 'beforeInsert: %s'% AuthLevel

		if AuthLevel == 0 :

			DrAcc 	= ""
			DrCat 	= ""
			DrCur 	= ""

			CrAcc 	= ""
			CrCat 	= ""
			CrCur 	= "" 

			controls_list 	= request.form
			ListTillAcc		= [item for item in controls_list if "TillAccount" in item]
			ListAmount 		= [item for item in controls_list if "Amount" in item]
			ListTillAcc.sort()
			ListAmount.sort()

			TotalTillAcc 	= len(ListTillAcc)
			AccObj 			= MKT_ACCOUNT.query
			for nub in range(0,TotalTillAcc):

				DrAcc 	= request.form[ListTillAcc[nub]]
				Amount 	= str(request.form[ListAmount[nub]])

				FilterAcc = AccObj.get(DrAcc)
				if FilterAcc:

					DrCat	= FilterAcc.AccCategory
					DrCur 	= FilterAcc.Currency

				VaultObj   	= mktuser.getVaultInfo(DrCur)
				if VaultObj:
					CrAcc 	=	VaultObj.ID
					CrCur 	=	VaultObj.Currency
					CrCat 	=	VaultObj.AccCategory

				Amo 		= Amount.replace(',','')
				Amo   		= Decimal(Amo)
				Tran  		= request.form['Transaction']
				TranDate 	= request.form['TranDate']
				Note 		= request.form['Note']
				Ref 		= request.form['ID']
				Module 		= "TO"

				Audit 		= mktaudit.getAuditrail()
				Inputter	= Audit['Inputter']
				Createdon 	= Audit['Createdon']
				Authorizer 	= Audit['Authorizer']
				Authorizeon	= Audit['Authorizeon']
				Branch 		= Audit['Branch']

				# Call function to commit add account by currency 
				CheckAccounting = mktteller.setCommitAccouting(Inputter,Createdon,Authorizer,Authorizeon,Branch,DrAcc,DrCat,DrCur,CrAcc,CrCat,CrCur,Amo,Module,Tran,TranDate,Ref,Note)
				if not CheckAccounting[0]:
					flash(CheckAccounting[1])
					return False

		return True

	@staticmethod
	def beforeAuthorize():
		# Authorize have two transcations INAU, RNAU 
		try:
			
			# AuthLevel 	= g.getNAuthorize
			# print 'beforeAuthorize: %s'% AuthLevel
			ID 				= 	g.formID
			TillOperation 	=	MKT_TILL_OPERATION_INAU.query.get(ID)
			
			if not TillOperation:

				flash(msg_error + "Till open %s not found." %ID)
				return False

			else:
				if TillOperation.Operation == "C":
					flash(msg_error + "The record is till close could not authorize in till open. ID: %s" %ID)
					return False

				DetailObj 		= MKT_TO_DETAIL_INAU.query.filter(MKT_TO_DETAIL_INAU.ID==ID)
				if not DetailObj.all():
					flash(msg_error + "Till open detail %s not found." %ID)
					return False

				CheckAccounting = mktteller.setAuthorizeTillOperation('TO',ID)
				if not CheckAccounting[0]:
					db.session.rollback()
					flash(CheckAccounting[1])
					return False

			return True
		except Exception, e:
			flash(msg_error+'%s'%e)
			db.session.rollback()
			db.session.close()
			return False

	@staticmethod
	def reverseRec():

		try:
			
			AuthLevel 	= g.getNAuthorize
			# print 'reverseRec: %s'% AuthLevel
			ID 			= g.formID
			Check = mktteller.validationReverse(MKT_TILL_OPERATION,MKT_TILL_OPERATION_INAU,ID)
		
			if not Check[0]:
				TillOperation 	=	MKT_TILL_OPERATION.query.get(ID)
				if TillOperation:
					if TillOperation.Operation == "C":
						return True,msg_error + "The record is till close could not reverse in till open. ID: %s" %ID
				
				Audit 		= mktaudit.getAuditrail()
				Inputter	= Audit['Inputter']
				Createdon 	= Audit['Createdon']
				CheckAccounting = mktteller.setReverseMultiForm(AuthLevel,"TO",MKT_TILL_OPERATION,MKT_TILL_OPERATION_INAU,MKT_TO_DETAIL,MKT_TO_DETAIL_INAU,ID,Inputter,Createdon)
				if not CheckAccounting[0]:
					#Catch error
					db.session.rollback()
					db.session.close()
					return True,CheckAccounting[1]

				#Successfully
				db.session.commit()
				db.session.close()
				return True,CheckAccounting[1]

			else:
				return Check

		except Exception, e:
			db.session.rollback()
			db.session.close()
			return True,msg_error+"%s"%e
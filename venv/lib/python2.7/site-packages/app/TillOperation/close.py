from app.mktcore.wtfimports import *
from app.mktcore.imports 	import *
from .models import *
import time
from decimal import *

import app.tools.mktaccount 	as mktaccount
import app.tools.mktparam   	as mktparam
import app.tools.mktdate 		as mktdate
import app.tools.mktmoney 		as mktmoney
import app.tools.mktaccounting 	as mktaccounting
import app.tools.mktteller 		as mktteller
import app.tools.user 			as mktuser
import app.tools.mktaudit 		as mktaudit
import app.tools.mktfundtransfer 	as mktfundtransfer

from app.Account.models 	import *
from app.TellerParam.models import *
from app.CashAccount.models import *

def loadTran():
	Param = mktparam.getTellerParam()
	TranID=''
	if Param:
		TranID = Param.CloseTillTran
		
	return TranID

def loadCashAccount():
	CashAccount 	= ""
	UserObj = mktuser.getUser()
	if UserObj:
		CashAccount = UserObj.CashAccount

	return CashAccount

def loadAccount():
	result 	= []
	Branch 	= mktuser.getCurrentBranch()
	Param 	= mktparam.getTellerParam()
	if Param:		
		row=MKT_ACCOUNT.query.filter_by(Branch=Branch,AccCategory=Param.TillCategory).\
							order_by(MKT_ACCOUNT.ID.asc()).\
							all()
		if row:
			result=row
	return result


def loadCurrentDate():
	return 	mktdate.getBankDate()

class FRM_TILL_CLOSE(exform):

	CashID 	= TextField("Cash ID",default=loadCashAccount)
	Operation 	= TextField("Operation ",default='C')
	Transaction = TextField(requiredlabel("Transaction","*"),
							validators=[validators.Required()],
							default=loadTran)
	TranDate   	= DateField(requiredlabel("Transaction Date", "*"), 
							validators=[validators.Required()],
							default=loadCurrentDate)
	Reference 	= TextField(getLanguage("Reference"),[validators.Length( max=35)])
	Note 		= TextAreaField(requiredlabel("Note", "*"),[validators.Length(max=50),validators.Required()])

	TillAccount = QuerySelectField(requiredlabel('Till Account', "*"),
							[validators.Required()],
							query_factory=loadAccount, 
							get_label=lambda a: a.ID + " - " + a.AccName,
							allow_blank=True,
							blank_text='--None--',
							default='--None--',
							description="1-DETAILS")
	Category 	= TextField("Category",description="1-DETAILS")
	Currency 	= TextField("Currency",description="1-DETAILS")
	Balance 	= TextField("Balance",description="1-DETAILS")
	Amount 		= TextField(requiredlabel("Amount","*"),
							validators=[validators.Required()],
							default=0,
							description="1-DETAILS")

	def validate_TranDate(form, field):

		TranDate 	= form.TranDate.data

		try:

			TranDate = datetime.strptime(str(TranDate),'%Y-%m-%d').date()

		except:
			raise ValidationError("This field must be in date format.")

		Check = mktfundtransfer.checkPreMonthDateTransaction(TranDate)

		if Check:

			raise ValidationError(Check)

	def validate_TillAccount(form,field):

		if form.TillAccount.data == '' :
			raise ValidationError("Please selecte Till Account!")

		TillAccount = []
		controls_list 	= request.form
		ListTillAcc		= [item for item in controls_list if "TillAccount" in item]
		ListTillAcc.sort()
		TotalTillAcc=len(ListTillAcc)

		for nub in range(0,TotalTillAcc):
			TillAccount.append(request.form[ListTillAcc[nub]])

		DuplicateAcc   = [x for x in TillAccount if TillAccount.count(x) > 1]
		if DuplicateAcc:
			raise ValidationError("Can not selecte the same account#%s"%DuplicateAcc[0])

	def validate_CashID(form, field):
		if form.CashID.data =='':
			raise ValidationError("Your user don't have vault account!")

	def validate_Amount(form, field):

		VaultAccountObj = []
		dic 		= {}
		ListCurAmo  = []
		TillAccount = ''
		Currency    = ''
		TellerParam 	= mktparam.getTellerParam()
		if TellerParam:
			UnBalance 		= TellerParam.UnBalance
		else:
			raise ValidationError("Please set Teller Parameter first..")

		AccObj 			= MKT_ACCOUNT.query
		controls_list 	= request.form
		ListTillAcc		= [item for item in controls_list if "TillAccount" 	in item]
		ListCurrency 	= [item for item in controls_list if "Currency"    	in item]
		ListAmount 		= [item for item in controls_list if "Amount" 		in item]
		

		ListTillAcc.sort()
		ListCurrency.sort()
		ListAmount.sort()

		TotalTillAcc=len(ListTillAcc)
		for nub in range(0,TotalTillAcc):

			TillAccount 	= str(request.form[ListTillAcc[nub]])
			Currency 		= str(request.form[ListCurrency[nub]])
			Amount 			= str(request.form[ListAmount[nub]]).replace(',','')
			Amount 			= float(Amount)
			# Sum Total Amount by Currency
			if Currency in dic: 
				TotalAmount = dic[Currency]
				TotalAmount = Amount+TotalAmount
				dic.update({Currency:TotalAmount})
			else:
				dic.update({Currency:Amount})
			
			VaultAccountObj   = mktuser.getVaultInfo(Currency)
			if VaultAccountObj:

				FilterTillAcc = AccObj.get(TillAccount)
				if FilterTillAcc:
					Balance 	= float(FilterTillAcc.Balance)
					BranchTill 	= FilterTillAcc.Branch
					BranchVault = VaultAccountObj.Branch
					if BranchVault != BranchTill:

						raise ValidationError("Difference between branch Vault and Till.")

					if UnBalance == "N":
						if Amount < Balance:
							raise ValidationError("Cannot close till with amount less than balance.")

						elif Amount > Balance:
							raise ValidationError("Cannot close till with amount more than balance.")

				# CheckBalance2 = mktaccounting.checkMaxMinBalance(TillAccount, Currency, Decimal(Amount), "Cr")
				# if CheckBalance2:
				# 	raise ValidationError(CheckBalance2)

				# CheckBalance1 = mktaccounting.checkMaxMinBalance(VaultAccountObj.ID,VaultAccountObj.Currency, Decimal(Amount), "Dr")
				# if CheckBalance1:
				# 	raise ValidationError(CheckBalance1)

			else:
				raise ValidationError("Your user don't have vault account in currency%s"%Currency)


	@staticmethod
	def moneyField():
		return [["Amount","Currency"],["Balance","Currency"]]

	@staticmethod
	def setWidth():
		control_list = [('Operation',len2),('Transaction',len2),
						('TranDate',len3),('Currency',len1),
						('CashID',len2),('Category',len1)]
		return control_list
	
	@staticmethod
	def listField():

		Fields = ["ID", "CashID","Transaction", "TranDate", "Reference", "Note"]
		return Fields, ["Operation*EQ*C"]

	@staticmethod
	def setVisible():
		control_list=['Operation','Transaction','Category']
		return control_list

	@staticmethod
	def setDisable():
		controls_list=["CashID" ,"Transaction","TranDate","Balance","Category","Currency","Operation"]
		return controls_list

	@staticmethod
	def isMultiValue():
		controls_list=["1-DETAILS"]
		return controls_list

	@staticmethod
	def hotField():
		hotfield = []

		fielddisplay = "$('#Balance').val(data.Balance);$('#Currency').val(data.Currency);$('#Category').val(data.Category);$('#Amount').val(data.Balance)" 
		varname = "TillAccount:$('#TillAccount').val()"
		fun = ["TillAccount", varname, fielddisplay, "/Morakot/TillOperationAcc", "click"]
		hotfield.append(fun)

		return hotfield
		


	@staticmethod
	def beforeNewID ():
		Check = mktteller.isUserVaultAccount()
		if not Check[0]:
			return True,Check[1]
		else:
			#Mean that user have cash account.
			return False,''
			
	@staticmethod
	def formReadOnly():
		return "AUTH"

	@staticmethod
	def findinHist():
		return True

	@staticmethod
	def IsAcceptOverride():
		#write  your stuff here and then return True if you want to raise accept override and put yourmessage
		ListMsg         = []
		controls_list 	= request.form
		ListTillAcc		= [item for item in controls_list if "TillAccount" in item]
		ListAmount 		= [item for item in controls_list if "Amount" in item]
		

		ListTillAcc.sort()
		ListAmount.sort()
		

		TotalTillAcc=len(ListTillAcc)
		for nub in range(0,TotalTillAcc):
			
			TillAccount 	= request.form[ListTillAcc[nub]]
			TransAmount 	= str(request.form[ListAmount[nub]])
			# Balance 		= float(request.form[ListBalance[nub]])

			query = MKT_ACCOUNT.query.get(TillAccount)

			if query:

				TillAccName     = query.AccName
				Currency 		= query.Currency
				Balance 		= Decimal(query.Balance)			

			Amo     = str(TransAmount)
			Amo 	= Amo.replace(',','')
			Amo   	= Decimal(Amo)
			# Shortage
			if Amo < Balance:
				Amo = Balance - Amo
				ListMsg.append('Till Account# %s has a shortage of %s <br />'\
				%(TillAccount,mktmoney.toMoney(float(Amo),mktmoney.getCurrencyObj(Currency),2)))
			#Surplus
			elif Amo > Balance:
				Amo = Amo - Balance
				ListMsg.append('Till Account# %s has a surplus of %s <br />'\
				%(TillAccount,mktmoney.toMoney(float(Amo),mktmoney.getCurrencyObj(Currency),2)))
			
		recordTill=''
		for item in ListMsg	:
			recordTill += item
		Msg="%s %sDo you want to procceed?" % (recordTill ,'<br/>' if recordTill !='' else '')
		MsgShow = True if recordTill else False
		return MsgShow,Msg #

		
	@staticmethod
	def beforeInsert():
		# print g.formID
		AuthLevel 	= g.getNAuthorize
		# print 'beforeInsert: %s'% AuthLevel

		if AuthLevel == 0 :

			DrAcc 	= ""
			DrCat 	= ""
			DrCur 	= ""

			CrAcc 	= ""
			CrCat 	= ""
			CrCur 	= ""

			Audit 		= mktaudit.getAuditrail()
			Inputter	= Audit['Inputter']
			Createdon 	= Audit['Createdon']
			Authorizer 	= Audit['Authorizer']
			Authorizeon	= Audit['Authorizeon']
			Branch 		= Audit['Branch']

			TellerParam 	= mktparam.getTellerParam()
			if TellerParam:
				UnBalance 		= TellerParam.UnBalance

			controls_list 	= request.form
			ListTillAcc		= [item for item in controls_list if "TillAccount" in item]
			ListAmount 		= [item for item in controls_list if "Amount" in item]
			ListTillAcc.sort()
			ListAmount.sort()

			Tran  			= request.form['Transaction']
			TranDate 		= request.form['TranDate']
			Note 			= request.form['Note']
			Ref 			= request.form['ID']
			Module 			= "TC"
			Mode 			= ""

			AccObj 			= MKT_ACCOUNT.query
			TotalTillAcc 	= len(ListTillAcc)

			for nub in range(0,TotalTillAcc):

				TillAccout 	= request.form[ListTillAcc[nub]]
				Amount 		= str(request.form[ListAmount[nub]])
				Amo 		= Amount.replace(',','')
				Amo   		= Decimal(Amo)

				FilterAcc = MKT_ACCOUNT.query.get(TillAccout)
				if FilterAcc:

					Balance 		= Decimal(FilterAcc.Balance)
					TillAccount 	= FilterAcc.ID
					TillCategory	= FilterAcc.AccCategory
					TillCurrency 	= FilterAcc.Currency

				VaultObj   	= mktuser.getVaultInfo(TillCurrency)
				if VaultObj:
					VaultAccount 	=	VaultObj.ID
					VaultCategory 	=	VaultObj.AccCategory
					VaultCurrency 	=	VaultObj.Currency

				# check Balance and Amount (Shortage and Surplus)
				# Shortage
				if Amo < Balance:
					if UnBalance == "Y":

						DrAcc = VaultAccount
						DrCat = VaultCategory
						DrCur = VaultCurrency

						CrAcc = TillAccount
						CrCat = TillCategory
						CrCur = TillCurrency

						# Call function to commit add account by currency 
						CheckAccounting = mktteller.setCommitAccouting(Inputter,Createdon,Authorizer,Authorizeon,Branch,DrAcc,DrCat,DrCur,CrAcc,CrCat,CrCur,Amo,Module,Tran,TranDate,Ref,Note,Mode)
						if not CheckAccounting[0]:
							flash(CheckAccounting[1])
							return False

						#Post Shortage Accout - 
						ShortageAcc  = mktaccount.getShortageAccount(CrCur,Branch)
						if ShortageAcc:
							Amo = Balance - Amo
							DrAcc = ShortageAcc.ID
							DrCat = ShortageAcc.AccCategory
							DrCur = ShortageAcc.Currency
						else:
							flash(msg_error+"Shortage Account not found.")
							return False

						CrAcc = TillAccount
						CrCat = TillCategory
						CrCur = TillCurrency

						# Call function to commit add account by currency 
						CheckAccounting = mktteller.setCommitAccouting(Inputter,Createdon,Authorizer,Authorizeon,Branch,DrAcc,DrCat,DrCur,CrAcc,CrCat,CrCur,Amo,Module,Tran,TranDate,Ref,Note,Mode)
						if not CheckAccounting[0]:
							flash(CheckAccounting[1])
							return False
					
					else:
						flash(msg_error+"Cannot close till with amount less than balance.")
						return False

				# check Balance and Amount (Shortage and Surplus)
				# Surplus
				elif Amo > Balance:

					if UnBalance == "Y":

						DrAcc = VaultAccount
						DrCat = VaultCategory
						DrCur = VaultCurrency

						CrAcc = TillAccount
						CrCat = TillCategory
						CrCur = TillCurrency

						# Call function to commit add account by currency 
						CheckAccounting = mktteller.setCommitAccouting(Inputter,Createdon,Authorizer,Authorizeon,Branch,DrAcc,DrCat,DrCur,CrAcc,CrCat,CrCur,Amo,Module,Tran,TranDate,Ref,Note,Mode)
						if not CheckAccounting[0]:
							flash(CheckAccounting[1])
							return False
							
						#Post Surplus Accout + :
						Surplus  = mktaccount.getSurplusAccount(CrCur,Branch)
						Amo = Amo - Balance

						DrAcc = TillAccount
						DrCat = TillCategory
						DrCur = TillCurrency
						if Surplus:
							CrAcc = Surplus.ID 
							CrCat = Surplus.AccCategory 
							CrCur = Surplus.Currency
						else:
							flash(msg_error+"Surplus Account not found.")
							return False
						# Call function to commit add account by currency 
						CheckAccounting = mktteller.setCommitAccouting(Inputter,Createdon,Authorizer,Authorizeon,Branch,DrAcc,DrCat,DrCur,CrAcc,CrCat,CrCur,Amo,Module,Tran,TranDate,Ref,Note,Mode)
						if not CheckAccounting[0]:
							flash(CheckAccounting[1])
							return False
					else:
						flash(msg_error+"Cannot close till with amount more than balance.")
						return False
				else:
					DrAcc = VaultAccount
					DrCat = VaultCategory
					DrCur = VaultCurrency

					CrAcc = TillAccount
					CrCat = TillCategory
					CrCur = TillCurrency

					# Call function to commit add account by currency 
					CheckAccounting = mktteller.setCommitAccouting(Inputter,Createdon,Authorizer,Authorizeon,Branch,DrAcc,DrCat,DrCur,CrAcc,CrCat,CrCur,Amo,Module,Tran,TranDate,Ref,Note,Mode)
					if not CheckAccounting[0]:
						flash(CheckAccounting[1])
						return False
				
		return True

	@staticmethod
	def beforeAuthorize():
		# Authorize have two transcations INAU, RNAU 
		try:
			
			# AuthLevel 	= g.getNAuthorize
			# print 'beforeAuthorize: %s'% AuthLevel
			ID 				= 	g.formID
			TillOperation 	=	MKT_TILL_OPERATION_INAU.query.get(ID)
			
			if not TillOperation:

				flash(msg_error + "Till close %s not found." %ID)
				return False

			else:
				if TillOperation.Operation == "O":
					flash(msg_error + "The record is till open could not authorize in till close. ID: %s" %ID)
					return False
				DetailObj 		= MKT_TO_DETAIL_INAU.query.filter(MKT_TO_DETAIL_INAU.ID==ID)
				if not DetailObj.all():
					flash(msg_error + "Till close detail %s not found." %ID)
					return False

				CheckAccounting = mktteller.setAuthorizeTillOperation('TC',ID)
				if not CheckAccounting[0]:
					db.session.rollback()
					flash(CheckAccounting[1])
					return False

			return True
		except Exception, e:
			flash(msg_error+'%s'%e)
			db.session.rollback()
			db.session.close()
			return False

	@staticmethod
	def reverseRec():

		try:
			
			AuthLevel 	= g.getNAuthorize
			# print 'reverseRec: %s'% AuthLevel
			ID 			= g.formID
			Check = mktteller.validationReverse(MKT_TILL_OPERATION,MKT_TILL_OPERATION_INAU,ID)
		
			if not Check[0]:
				TillOperation 	=	MKT_TILL_OPERATION.query.get(ID)
				if TillOperation:
					if TillOperation.Operation == "O":
						return True,msg_error + "The record is till open could not reverse in till close. ID: %s" %ID
				
				Audit 		= mktaudit.getAuditrail()
				Inputter	= Audit['Inputter']
				Createdon 	= Audit['Createdon']
				CheckAccounting = mktteller.setReverseMultiForm(AuthLevel,"TC",MKT_TILL_OPERATION,MKT_TILL_OPERATION_INAU,MKT_TO_DETAIL,MKT_TO_DETAIL_INAU,ID,Inputter,Createdon)
				if not CheckAccounting[0]:
					#Catch error
					db.session.rollback()
					db.session.close()
					return True,CheckAccounting[1]

				#Successfully
				db.session.commit()
				db.session.close()
				return True,CheckAccounting[1]

			else:
				return Check

		except Exception, e:
			db.session.rollback()
			db.session.close()
			return True,msg_error+"%s"%e
from app.mktcore.wtfimports 				import *
from app.mktcore.imports 					import *
from .models 								import *
from decimal 								import Decimal

from app.Currency.models 					import MKT_CURRENCY
from app.Category.models 					import MKT_CATEGORY
from app.AccProduct.models 					import MKT_ACC_PRODUCT
from app.Account.models 					import MKT_ACCOUNT

import app.tools.mktdate 					as mktdate
import app.tools.mktaccounting 				as mktaccounting
import app.tools.loantools.nonworkingday	as nonworkingday
import app.tools.mktholiday 				as mktholiday
import app.tools.user 						as mktuser

def custom_ValueDate(FrequencyType,ValueDate):

	BankDate 		= mktdate.getBankDate()
	Holiday 		= mktholiday.getHoliday()

	if FrequencyType:

		if ValueDate:
			ValueDate 		= datetime.strptime(str(ValueDate),'%Y-%m-%d').date()
			CheckFormatDate = mktdate.isDateISO(str(ValueDate))
			# CheckHoliday 	= nonworkingday.isNonWorkingDay(ValueDate, Holiday)

			if not CheckFormatDate:
				return False, "Incorrect date format, should be YYYY-MM-DD"

			elif str(ValueDate) < str(BankDate):
				return False, "Value Date must be bigger than or equal to System Bank Date %s."%BankDate

			''' Uncomment this to validate holiday '''
			# elif CheckHoliday:
			# 	raise ValidationError("Value Date must be different holiday.")
		else:
			
			return False, "Vaule Date is required."
	return True, ''


def custom_MaturityDate(FrequencyType, ValueDate, MaturityDate):

	BankDate 		= mktdate.getBankDate()
	Holiday 		= mktholiday.getHoliday()

	if FrequencyType:

		if MaturityDate:
			MaturityDate 	= datetime.strptime(str(MaturityDate),'%Y-%m-%d').date()
			CheckFormatDate = mktdate.isDateISO(str(MaturityDate))
			# CheckHoliday 	= nonworkingday.isNonWorkingDay(MaturityDate, Holiday)

			if not CheckFormatDate:
				return False, "Incorrect date format, should be YYYY-MM-DD"

			elif str(MaturityDate) < str(BankDate):
				return False,"Maturity Date must be bigger than or equal to System Bank Date %s."%BankDate

			elif str(MaturityDate) < str(ValueDate):
				return False, "Maturity Date must be bigger than or equal to Value Date."
			
			''' Uncomment this to validate holiday '''
			# elif CheckHoliday:
			# 	raise ValidationError("Maturity Date must be different holiday.")

	return True, ''


def getAllAccountProductCategory():
	AccProObj = MKT_ACC_PRODUCT.query
	Category = [str(row.CategoryList) for row in AccProObj]
	return Category


class FRM_STANDING_ORDER(exform):
	Amortize 		=	SelectField(requiredlabel("Amortize", "*"),
							choices=[('Y', 'Yes'),('N', 'No')],
							coerce=str)
	DrAccount 		= 	RemoteTextField("Debit Account")
	DrCategory 		=	QuerySelectField(requiredlabel("Debit Category","*"),
							query_factory=mktaccounting.loadCategoryWithCashCategory,
							get_label=lambda a: a.ID + " - " + a.Description,
							allow_blank=True,
							blank_text=u'--None--',
							validators=[validators.Required()],
							)
	CrAccount 		= 	RemoteTextField("Credit Account")
	CrCategory 		=	QuerySelectField(requiredlabel("Credit Category","*"),
							query_factory=mktaccounting.loadCategoryWithCashCategory,
							get_label=lambda a: a.ID + " - " + a.Description,
							allow_blank=True,
							blank_text=u'--None--',
							validators=[validators.Required()],
							)
	Currency 		= 	QuerySelectField(requiredlabel('Currency', "*"),
							query_factory=mktaccounting.loadCurrency,
							get_label=u'ID',
							blank_text=u'--None--',
							validators=[validators.Required()],
							default=lambda:mktaccounting.loadCurrency(Default=True),
							)

	FrequencyType 		=	SelectField(requiredlabel(getLanguage("Frequency Type"),"*"),
							choices=[('', '--None--'),
									('M', 'Monthly'),
									('D', 'Daily'),
									],
							coerce=str,
							default = u'--None--',
							validators=[validators.Required()]
							)
	Amount 				= 	TextField(requiredlabel("Amount","*"))


	Transaction 		= 	QuerySelectField(requiredlabel('Transaction', "*"),
							query_factory=mktaccounting.loadTransaction,
							get_label=lambda a: a.ID + " - " + a.Description,
							allow_blank=True,
							blank_text=u'--Choose Transaction--',
							validators=[validators.Required()],
							)
	ValueDate 			=	DateField(requiredlabel("Value Date","*"), validators=[validators.Required()], default=mktdate.getBankDate)
	MaturityDate 		=	DateField(requiredlabel("Maturity Date","*"), validators=[validators.Required()])


	Reference 			= 	TextField("Reference",[validators.Length(max=35)])
	Note 				= 	TextAreaField(requiredlabel("Note", "*"),[validators.Length(max=100),validators.Required()])
	Terminate 			=	SelectField(requiredlabel("Terminate", "*"),
							choices=[('N', 'No'),('Y', 'Yes')],
							coerce=str,
							description='1-Detail')
	LastRunDate			= 	TextField("Last Booking Date", description='1-Detail')
	NextRunDate			= 	TextField("Next Booking Date", description='1-Detail')
	BookAmount			= 	TextField("Book Amount",default = Decimal(0),description='1-Detail')
	EarnedAmount		= 	TextField("Earned Amount",default = Decimal(0),description='1-Detail')
	OutstandingAmount 	= 	TextField("Outstanding Amount",default = Decimal(0),description='1-Detail')

	def validate_Terminate(form, field):
		Terminate 		= request.form["Terminate"] if request.method == 'POST' else ""
		ID 				= request.form['ID']
		StandingObj = MKT_STANDING_ORDER_INAU.query.get(ID)
		ValueDate 		= request.form["ValueDate"] if request.method == 'POST' else ""
		BankDate 	= mktdate.getBankDate()
		if ValueDate > str(BankDate) and Terminate =='Y':
			raise ValidationError("Cannot process because it's not yet booking amount")
		if not StandingObj:
			StandingObj = MKT_STANDING_ORDER.query.get(ID)
		if not StandingObj:
			if Terminate == 'Y':
				raise ValidationError('You can not select terminate today to YES, Because record not yet created. Please change to No')

	def validate_ValueDate(form, field):
		
		FrequencyType 	= request.form["FrequencyType"] if request.method == 'POST' else ""
		ValueDate 		= request.form["ValueDate"] if request.method == 'POST' else ""
		ID 				= request.form['ID']
		StandingObj = MKT_STANDING_ORDER_INAU.query.get(ID)
		if not StandingObj:
			StandingObj = MKT_STANDING_ORDER.query.get(ID)
		if StandingObj:
			if not StandingObj.ValueDate == ValueDate:

				CheckObj = custom_ValueDate(FrequencyType,ValueDate)
				if not CheckObj[0]:
					raise ValidationError(CheckObj[1])
		else:
			CheckObj = custom_ValueDate(FrequencyType,ValueDate)
			if not CheckObj[0]:
				raise ValidationError(CheckObj[1])

	def validate_MaturityDate(form, field):
		FrequencyType 	= request.form["FrequencyType"] if request.method == 'POST' else ""
		ValueDate 		= request.form["ValueDate"] if request.method == 'POST' else ""
		MaturityDate 	= request.form["MaturityDate"] if request.method == 'POST' else ""
		CheckObj 		= custom_MaturityDate(FrequencyType, ValueDate, MaturityDate)
		if not CheckObj[0]:
			raise ValidationError(CheckObj[1])

	def validate_Amount(form, field):
		Amount = request.form['Amount']
		try:
			Amount = float(Amount)
		except:
			raise ValidationError("This field must be in numeric format.")

		if float(Amount) <= float(0):
			raise ValidationError("Must be bigger than zero")

	def validate_DrAccount(form, field):
		try:
			DrAccount 		= form.DrAccount.data
			DrCategory 		= request.form['DrCategory']  if 'DrCategory' in request.form else ''
			DrCurrency 		= request.form['Currency']  if 'Currency' in request.form else ''
			CrAccount 		= form.CrAccount.data
			Amount 			= Decimal(form.Amount.data)

			if DrAccount and Amount !=0:
				AccObj = MKT_ACCOUNT.query.get(DrAccount)
				if AccObj :
					AccCategory = AccObj.AccCategory
					AccCurrency = AccObj.Currency
					if AccCategory != DrCategory:
						raise ValidationError("Debit category not belong to account.")
					if AccCurrency != DrCurrency:
						raise ValidationError("Account #%s not belong to currency %s."%(AccObj.ID,DrCurrency))

				CheckBalance = mktaccounting.checkMaxMinBalance(DrAccount, DrCurrency, Decimal(Amount), "Dr")
				if CheckBalance:
					raise ValidationError(CheckBalance)

				if DrAccount == CrAccount:
					raise ValidationError("Debit account must be different Credit account.")

		except:
			raise

	def validate_DrCategory(form, field):

		Branch 			= mktuser.getCurrentBranch()
		DrAccount 		= form.DrAccount.data
		DrCategory 		= request.form['DrCategory'] if 'DrCategory' in request.form else ''
		DrCurrency 		= request.form['Currency'] if 'Currency' in request.form else ''
		Terminate 		= request.form['Terminate'] if 'Terminate' in request.form else ''
		OutAmount 		= Decimal(form.OutstandingAmount.data)
		Amount 			= Decimal(form.Amount.data)
		if DrCategory:
			DrGLKey 		= mktaccounting.getConsolKey(DrCategory, DrCurrency)
			ListCashCategory = getAllAccountProductCategory()
			
			if DrCategory in ListCashCategory:
				if not DrAccount:
					CategoryDesc = DrCategory
					CategoryObj = MKT_CATEGORY.query.get(DrCategory)
					if CategoryObj:
						CategoryDesc = '%s - %s'%(DrCategory,CategoryObj.Description)
					raise ValidationError("Debit account is required if you choose category %s"% CategoryDesc)

			if Terminate == "Yes":
				CheckBalance 	= mktaccounting.getValidateConsolBalance(OutAmount, DrCategory, DrCurrency, Branch, 'Dr', DrGLKey)

			else:
				CheckBalance 	= mktaccounting.getValidateConsolBalance(Amount, DrCategory, DrCurrency, Branch, 'Dr', DrGLKey)

			if not CheckBalance[0]:
				raise ValidationError(CheckBalance[1])

	def validate_CrAccount(form, field):
		try:
			CrAccount 		= form.CrAccount.data
			CrCategory 		= request.form['CrCategory']  if 'CrCategory' in request.form else ''
			CrCurrency 		= request.form['Currency']  if 'Currency' in request.form else ''
			Amount 			= Decimal(form.Amount.data)

			if CrAccount and Amount !=0:
				AccObj = MKT_ACCOUNT.query.get(CrAccount)
				if AccObj :
					AccCategory = AccObj.AccCategory
					AccCurrency = AccObj.Currency
					if AccCategory != CrCategory:
						raise ValidationError("Credit category not belong to account.")

					if AccCurrency != CrCurrency:
						raise ValidationError("Account #%s not belong to currency %s."%(AccObj.ID,CrCurrency))

				CheckBalance = mktaccounting.checkMaxMinBalance(CrAccount, CrCurrency, Decimal(Amount), "Cr")
				if CheckBalance:
					raise ValidationError(CheckBalance)
		except:
			raise

	def validate_CrCategory(form, field):

		Branch 			= mktuser.getCurrentBranch()
		CrAccount 		= form.CrAccount.data
		CrCategory 		= request.form['CrCategory'] if 'CrCategory' in request.form else ''
		CrCurrency 		= request.form['Currency'] if 'Currency' in request.form else ''
		Terminate 		= request.form["Terminate"] if "Terminate" in request.form  else ''
		OutAmount 	 	= Decimal(form.OutstandingAmount.data)
		Amount 			= Decimal(form.Amount.data)

		if CrCategory:
			CrGLKey 		= mktaccounting.getConsolKey(CrCategory, CrCurrency)
			ListCashCategory = getAllAccountProductCategory()
			
			if CrCategory in ListCashCategory:
				if not CrAccount:
					CategoryDesc = CrCategory
					CategoryObj = MKT_CATEGORY.query.get(CrCategory)
					if CategoryObj:
						CategoryDesc = '%s - %s'%(CrCategory,CategoryObj.Description)
					raise ValidationError("Credit account is required if you choose category %s"% CategoryDesc)
			
			if Terminate == "Y":
				CheckBalance 	= mktaccounting.getValidateConsolBalance(OutAmount, CrCategory, CrCurrency, Branch, 'Cr', CrGLKey)

			else:
				CheckBalance 	= mktaccounting.getValidateConsolBalance(Amount, CrCategory, CrCurrency, Branch, 'Cr', CrGLKey)

			if not CheckBalance[0]:
				raise ValidationError(CheckBalance[1])

	@staticmethod
	def setDisable():
		return [('OutstandingAmount'),('NextRunDate'),('LastRunDate'),'EarnedAmount','BookAmount']

	@staticmethod
	def moneyField():
		return [("Amount", "Currency")]

	@staticmethod
	def listField():
		return ["ID", "DrCategory", "DrAccount", "CrCategory", "CrAccount", "Currency", "Amount","EarnedAmount",
				"OutstandingAmount" ,"BookAmount", "Reference","Amortize" , "FrequencyType",
				"ValueDate", "MaturityDate", "LastRunDate","NextRunDate","Note" ]

	@staticmethod
	def formatMoney():
		return ["Amount"], "Currency"

	@staticmethod
	def setWidth():
		control_list= [ ('Currency', len2),		('ValueDate', len3),
						('MaturityDate', len3),	('Amortize', len2),
						('FrequencyType', len2)]
		return control_list

	@staticmethod
	def setDisableforEdit():
		return ['Amortize','FrequencyType']

	@staticmethod
	def formReadOnly():
		""" Checking Form ReadOnly
		return 	False 	=> Allow to Edit
				AUTH 	=> Disable Form
		"""
		ID = request.form["ID"] if request.method == "POST" else g.formID 

		Result = False
		StandingObj = MKT_STANDING_ORDER.query.get(ID)
		
		if StandingObj:

			if StandingObj.OutstandingAmount <= 0:
				Result = "AUTH"

		return Result



	@staticmethod
	def IsAcceptOverride():
		Msg = ''
		Override 	= False
		ID 			= request.form["ID"]
		Terminate 	= request.form["Terminate"] if "Terminate" in request.form  else ''
		if Terminate == "Y":
			Override 	= True
			Msg 		+= " You have select terminate YES, System will be closing standing order."
		Msg 		+= "Do you want to procceed?"

		return Override, Msg

	@staticmethod
	def IsAcceptOverrideINAU():
		Override 		= False
		ID 				= g.formID
		Msg 			= ""
		StandingObj 	= MKT_STANDING_ORDER_INAU.query.get(ID)
		Live 			= MKT_STANDING_ORDER.query.get(ID)
		if StandingObj:
			LiveVauleDate 	= ''
			FrequencyType 	= StandingObj.FrequencyType
			ValueDate 		= StandingObj.ValueDate
			MaturityDate 	= StandingObj.MaturityDate
			if StandingObj.Status != 'RNAU':
				if Live:
					LiveVauleDate = Live.ValueDate
				if LiveVauleDate != StandingObj.ValueDate and LiveVauleDate:
					CheckValidation = custom_ValueDate(FrequencyType,ValueDate)
					if CheckValidation[0]:
						CheckValidation = custom_MaturityDate(FrequencyType, ValueDate, MaturityDate)
					if not CheckValidation[0]:
						Validate = True
						Override = True
						Msg = msg_error+CheckValidation[1]
						return Override, Msg, Validate
			if StandingObj.Terminate == "Y":
				Override 	= True
				Msg 		+= " You have select terminate YES, System will be closing standing order."

		Msg 		+= "Do you want to procceed?"
		return Override, Msg

	@staticmethod
	def redirectAfterInsert():
		try:
			AuthLevel 	= g.getNAuthorize
			ID 			= request.form['ID']
			updateStandingOrderInfo(AuthLevel=AuthLevel,ID=ID)
			db.session.commit()
		except Exception as e:
			flash(msg_error+'%s'%e)
			db.session.rollback()
			db.session.close()
			raise

		return None

def updateStandingOrderInfo(**kwargs):
	""" Checking for update NextRunDate, LastRunDate, Outstanding, BookAmount"""
	try:
		AuthLevel 	= kwargs.get('AuthLevel')
		ID 			= kwargs.get('ID')
		BankDate 	= mktdate.getBankDate()
		Prev 		= ''
		if AuthLevel == 0 :#:self authorize record
			StandingObj 	= MKT_STANDING_ORDER.query.get(ID)
		else:
			StandingObj 	= MKT_STANDING_ORDER_INAU.query.get(ID)

		if StandingObj: 
			Amortize 		= StandingObj.Amortize
			MaturityDate 	= mktdate.getDateISO(StandingObj.MaturityDate)
			Amount 			= StandingObj.Amount
			FrequencyType 	= StandingObj.FrequencyType
			OutstandingAmount = StandingObj.OutstandingAmount
			#:Finding Prev Version for check user is updated record
			if StandingObj.Curr != '-1':
				PrevCurr 	= int(StandingObj.Curr)-1
				Prev 		= MKT_STANDING_ORDER_HIST.query.get('%s@%s'%(ID,PrevCurr))
				if AuthLevel == 1:
					Prev 	= MKT_STANDING_ORDER.query.get(ID)

			if not Prev: #:Save New Record


				#:Update Outstanding Amount
				if StandingObj.OutstandingAmount <= 0 :
					StandingObj.OutstandingAmount = StandingObj.Amount

				#:Update Booking Amount
				BookAmount 	= updateBookingAmount(	Amortize=Amortize,
													DateFrom=StandingObj.ValueDate,
													DateTo=StandingObj.MaturityDate,
													Amount=Amount,
													OutstandingAmount=StandingObj.OutstandingAmount)
				#:Update NextRunDate
				NextRunDate = updateNextRunDate(FrequencyType,BankDate,StandingObj.ValueDate,StandingObj.MaturityDate)
				#:Update LastRunDate
				LastRunDate = StandingObj.ValueDate

				StandingObj.BookAmount 			= BookAmount
				StandingObj.NextRunDate 		= NextRunDate
				StandingObj.LastRunDate 		= LastRunDate
				db.session.add(StandingObj)
			else:
				BookAmount 	= StandingObj.BookAmount
				NextRunDate = StandingObj.NextRunDate
				LastRunDate = StandingObj.LastRunDate
				#: Check User Update Amount
				if Prev.Amount != StandingObj.Amount:

					BookAmount 	= updateBookingAmount(	Amortize=Amortize,
														DateFrom=BankDate,
														DateTo=StandingObj.MaturityDate,
														Amount=Amount,
														OutstandingAmount=OutstandingAmount)

				#: Case Update Value Date
				if Prev.ValueDate != StandingObj.ValueDate:

					BookAmount 	= updateBookingAmount(	Amortize=Amortize,
														DateFrom=StandingObj.ValueDate,
														DateTo=StandingObj.MaturityDate,
														Amount=Amount,
														OutstandingAmount=OutstandingAmount)
					
					NextRunDate = updateNextRunDate(FrequencyType,BankDate,StandingObj.ValueDate,StandingObj.MaturityDate)
					LastRunDate = StandingObj.ValueDate

				#: Case Terminate will be update Booking amount to Outstanding
				if StandingObj.Terminate == "Y":
					# print 'i am here 1'
					BookAmount 					= StandingObj.OutstandingAmount
					NextRunDate 				= str(BankDate)
					LastRunDate 				= str(BankDate)
					StandingObj.MaturityDate	= str(BankDate)
				else:
					# print 'i am here.2'
					# check when change from N to Y and then change to N
					if Prev.Terminate == "N" and AuthLevel ==1 or Prev.Terminate == "Y" and AuthLevel==0 :
						#when undo record change terminate to 'N'
						if StandingObj.Terminate =='Y':
							BookAmount 					= Prev.BookAmount
							NextRunDate 				= Prev.NextRunDate
							LastRunDate 				= Prev.LastRunDate
							StandingObj.MaturityDate	= Prev.MaturityDate
							# print 'i am here 3'

				#: Case Update Amortize

				StandingObj.BookAmount 			= BookAmount
				StandingObj.NextRunDate 		= NextRunDate
				StandingObj.LastRunDate 		= LastRunDate
				db.session.add(StandingObj)

	except Exception as e:
		raise
	else:
		pass
	finally:
		pass

def updateBookingAmount(Amortize,DateFrom,DateTo,Amount,OutstandingAmount):
	'''
		Add one more day because getDateDiff doesn't count the first date
		20 - 25: 20 21 22 23 24 25 => getDateDiff() = 5
		Correct number of day should be 6 because 20 is count in as well.
	'''
	if Amortize == "Y":
		One_day 	= 1 
		NumOfDay 	= mktdate.getDateDiff(DateFrom, DateTo) + One_day
		BookAmount 	= Decimal(OutstandingAmount)/Decimal(NumOfDay)
	else:
		BookAmount 	= Amount
	return BookAmount

def updateNextRunDate(FrequencyType,BankDate,ValueDate,MaturityDate):
	''' After Insert
		1. Daily 	=> NextRunDate = ValueDate, LastRunDate = ValueDate
			
		2. Monthly 	=> NextRunDate = NextMonthEnd, LastRunDate = ValueDate
	'''
	#: Monthly process
	if FrequencyType == "M":
	
		NextMonthEnd 	= str(mktdate.getNextMonthEnd(ValueDate))

		if MaturityDate > NextMonthEnd:
			NextRunDate = NextMonthEnd

		else:
			NextRunDate = MaturityDate

	#: Daily Process
	elif FrequencyType == "D":
	
			NextRunDate 	= ValueDate

	return NextRunDate
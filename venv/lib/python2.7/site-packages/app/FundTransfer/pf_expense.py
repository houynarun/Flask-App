from flask 						import flash
from wtforms 					import DecimalField
from app.mktcore.wtfimports 	import *
from .models 					import *
from .. 						import app, db
from decimal 					import *
import time
from sqlalchemy 				import *

from datetime 					import datetime, date, timedelta
from app.tools.catetool 		import *
from app.Journal.models 		import MKT_JOURNAL
from app.Transaction.models 	import MKT_TRANSACTION
from app.Currency.models 		import MKT_CURRENCY
from app.Branch.models 			import MKT_BRANCH
from app.ConsolBalance.models 	import MKT_CONSOL_BALANCE
from app.Category.models 		import MKT_CATEGORY
from app.Account.models 		import MKT_ACCOUNT

import app.tools.mktaccounting 		as mktaccounting
import app.tools.mktaccount 		as mktaccount
import app.tools.mktdate 			as mktdate
import app.tools.mktsetting 		as mktsetting
import app.tools.mktfundtransfer 	as mktfundtransfer
import app.tools.user 				as mktuser
import app.tools.mktmoney 			as mktmoney
import app.tools.mktteller 			as mktteller
import app.tools.mktaudit 			as mktaudit

@app.route("/Morakot/CrAccount")
def getCrAccount():
	try:
		
		return mktaccount.searchProvidentAccount()

	except Exception, e:
		raise

@app.route("/Morakot/CrAccProductInfo")
def getCrAccProductInfo():
	try:
		
		CrAccount 		=	request.args.get("CrAccount") if "CrAccount" in request.args else ""
		AccObj 			=	MKT_ACCOUNT.query.get(CrAccount)
		CreditCategory 	=	""
		Currency 		=	""

		if AccObj:
			CreditCategory 	=	AccObj.AccCategory
			Currency 		=	AccObj.Currency

		return jsonify(CreditCategory=CreditCategory, Currency=Currency)

	except Exception, e:
		raise

def loadTransaction():
	return MKT_TRANSACTION.query

def loadCategory():

	JOURNAL_ENTRY_EXCLUDED = mktsetting.getExcludedCategories()

	return 	MKT_CATEGORY.query.\
			filter(~MKT_CATEGORY.ID.in_(JOURNAL_ENTRY_EXCLUDED)).\
			all()

def loadCurrency():
	return MKT_CURRENCY.query

def checkBalance(Amount, BalByKey, Type, DrCr):
	try:

		if Type == "Cr":
			BalByKey = (Decimal(BalByKey) + Amount)  if DrCr == "Cr" else (Decimal(BalByKey) - Amount)
		else:
			BalByKey = (Decimal(BalByKey) + Amount)  if DrCr == "Dr" else (Decimal(BalByKey) - Amount)

		return BalByKey

	except:
		raise

def loadCurrentDate():
	return 	mktdate.getBankDate()

def loadDebitCategory():

	return mktsetting.getAccSetting().ProvidentCat

def loadProvidentTran():

	return mktsetting.getAccSetting().ProvidentTran

class FRM_PF_EXPENSE(exform):

	DrCategory 		=	TextField(requiredlabel("Debit Category","*"), [validators.Required()], default=loadDebitCategory)
	CrAccount 		= 	RemoteTextField(requiredlabel(getLanguage('Account'), "*"), [validators.Required()])
	CrCategory 		=	TextField(requiredlabel("Category","*"), [validators.Required()])
	CrCurrency 		= 	TextField(requiredlabel("Currency","*"), [validators.Required()])
	Amount 			= 	TextField(requiredlabel("Amount","*"), [validators.Required()])
	Transaction 	=	TextField(requiredlabel("Transaction","*"), [validators.Required()], default=loadProvidentTran)

	TranDate 		= 	DateField(requiredlabel("Transaction Date", "*"), [validators.Required()], default=loadCurrentDate)
	Reference 		= 	TextField("Reference")
	Note 			= 	TextAreaField("Note")

	DrAccount 		=	TextField("Provident Account")
	DrCurrency 		=	TextField("Provident Currency")
	Module 			= 	TextField("Module", default="PF")

	def validate_DebitCategory(form, field):
		try:

			Branch 		= mktuser.getBranch(session["ChangeBranch"]).ID
			DrAcc 		= request.form['DrCategory']
			Currency 	= request.form['CrCurrency']
			Amount 		= Decimal(form.Amount.data)

			Balance 	=	mktaccounting.getValidateConsolBalance(Amount, DrAcc, Currency, Branch, 'Dr')
			
			if Balance[0] == False:

				raise ValidationError("Account#%s doesn't have sufficient fund. Current balance is %s." %(DrAcc, mktmoney.toMoney(float(Balance[1]), mktmoney.getCurrencyObj(Currency), 2)))

			# check if Category Cash at Vault
			if mktteller.isCashCateogry(DrAcc):

				CheckVault = mktteller.isUserVaultAccount()

				if not CheckVault[0]:

					raise ValidationError(CheckVault[1])

		except:
			raise

	def validate_CreditCategory(form, field):
		try:

			Branch 		= mktuser.getBranch(session["ChangeBranch"]).ID
			CrAcc 		= request.form['CrCategory']
			DrAcc 		= request.form['DrCategory']
			Currency 	= request.form['CrCurrency']
			Amount 		= Decimal(form.Amount.data)

			if DrAcc in CrAcc:
				raise ValidationError("Credit category must different debit category.")

			Balance 	=	mktaccounting.getValidateConsolBalance(Amount, CrAcc, Currency, Branch, 'Cr')
			
			if Balance[0] == False:

				raise ValidationError("Account#%s doesn't have sufficient fund. Current balance is %s." %(CrAcc, mktmoney.toMoney(float(Balance[1]), mktmoney.getCurrencyObj(Currency), 2)))

			# check if Category Cash at Vault
			if mktteller.isCashCateogry(CrAcc):

				CheckVault = mktteller.isUserVaultAccount()

				if not CheckVault[0]:

					raise ValidationError(CheckVault[1])

		except:
			raise

	def validate_TransactionDate(form, field):

		TranDate 	= form.TranDate.data

		try:

			TranDate = datetime.strptime(str(TranDate),'%Y-%m-%d').date()

		except:
			raise ValidationError("This field must be in date format.")

		Check = mktfundtransfer.checkPreMonthDateTransaction(TranDate)

		if Check:

			raise ValidationError(Check)

	def validate_Amount(form, field):

		Amount = request.form['Amount']

		try:

			Amount = float(Amount)

		except:
			raise ValidationError("This field must be in numeric format.")

		if float(Amount) <= float(0):

			raise ValidationError("Amount must be more than 0.")

	@staticmethod
	def moneyField():
		return [("Amount", "CrCurrency")]

	@staticmethod
	def formatMoney():
		return ["Amount"], "CrCurrency"

	@staticmethod
	def setWidth():
		control_list= [('TranDate', len3), ("CrCurrency", len1), ('CrCategory', len1)]
		return control_list

	@staticmethod
	def setVisible():		
		control_list = ['DrCategory', 'Transaction', 'DrAccount', 'DrCurrency','Module']
		return control_list

	@staticmethod
	def setDisable():
		return [('CrCategory'), ('CrCurrency')]

	@staticmethod
	def beforeAuthorize():

		ID 		= g.formID
		FBObj = MKT_FUND_TRANSFER_INAU.query.get(ID)
		if FBObj:
			Amount 		= 	Decimal(FBObj.Amount) if FBObj.Amount else Decimal(0)
			DrAccount 	= 	FBObj.DrAccount
			CrAccount 	=	FBObj.CrAccount
			DrCate 		= 	FBObj.DrCategory
			CrCate 		=	FBObj.CrCategory
			Cur 		= 	FBObj.CrCurrency
			Tran 		=	FBObj.Transaction
			TranDate	= 	FBObj.TranDate
			Noted 		=	FBObj.Note
			Branch 		=	FBObj.Branch
			Curr 		=	FBObj.Curr
			Inputter	=	FBObj.Inputter
			Createdon 	=	FBObj.Createdon
			Reference 	=	ID
			Audit 		= 	mktaudit.getAuditrail()
			Authorizer 	= 	Audit['Authorizer']
			Authorizeon = 	Audit['Authorizeon']
			Status 		=	FBObj.Status

			if ID[-1:] == 'R':
				DrAcc 	=	'Cr'
				CrAcc 	=	'Dr'
			else:
				DrAcc 	=	'Dr'
				CrAcc 	=	'Cr'

			DrBalance 	=	mktaccounting.getValidateConsolBalance(Amount, DrCate, Cur, Branch, DrAcc)
			CrBalance 	=	mktaccounting.getValidateConsolBalance(Amount, CrCate, Cur, Branch, CrAcc)

			if DrBalance[0] == False:
				flash(msg_error + "Account#%s doesn't have sufficient fund. Current balance is %s." %(DrCate, mktmoney.toMoney(float(DrBalance[1]), mktmoney.getCurrencyObj(Cur), 2)))
				return False
			elif CrBalance[0] == False:
				flash(msg_error + "Account#%s doesn't have sufficient fund. Current balance is %s." %(CrCate, mktmoney.toMoney(float(CrBalance[1]), mktmoney.getCurrencyObj(Cur), 2)))
				return False
			else:

				if ID[-1:] == 'R':
					mktfundtransfer.authFundTransfer(ID, Amount, CrAccount, CrCate, Cur, DrAccount, DrCate, Cur,
												Tran, TranDate, Noted, Branch, "PF", "", "Direct")
				else:
					mktfundtransfer.authFundTransfer(ID, Amount, DrAccount, DrCate, Cur, CrAccount, CrCate, Cur,
												Tran, TranDate, Noted, Branch, "PF", "Direct", "")
		else:
			flash(msg_error + " Provident fund entry not found.")
			db.session.rollback()
			return False

		return True

	@staticmethod
	def beforeInsert():
		
		try:
			
			NumOfAuth = g.getNAuthorize
			
			if int(NumOfAuth) == 0:
				
				Branch 		= mktuser.getBranch(session["ChangeBranch"]).ID
				ID 			= request.form['ID']
				CrAccount 	= request.form['CrAccount']
				DrAccount 	= ""
				Amount 		= request.form['Amount']
				DrCate 		= request.form['DrCategory']
				CrCate 		= request.form['CrCategory']
				TranDate 	= request.form['TranDate']
				Cur 		= request.form['CrCurrency']
				Tran 		= request.form['Transaction']
				Noted 		= request.form['Note']
				Reference 	=	ID
				
				mktfundtransfer.authFundTransfer(ID, Amount, DrAccount, DrCate, Cur, CrAccount, CrCate, Cur,
												Tran, TranDate, Noted, Branch, "PF", "Direct", "")


			return True

		except Exception, e:
			db.session.rollback()
			return False, msg_error+"%s"%e


	@staticmethod
	def listField():
		Fields = ["ID", "DrCategory", "CrAccount", "CrCategory", "Amount", 
		"TranDate"]
		return Fields, ["ID*LK*PF"]

	@staticmethod
	def hotField():
		hotfield = []

		fielddisplay 	= "$('#CrCategory').val(data.CreditCategory)"
		fielddisplay 	+= ";$('#CrCurrency').val(data.Currency)"
		varname 		= "CrAccount:$('#CrAccount').val()"
		fun 			= ["CrAccount", varname, fielddisplay, "/Morakot/CrAccProductInfo", "change"]
		hotfield.append(fun)

		return hotfield

	@staticmethod
	def formReadOnly():
		return "AUTH"
		
	@staticmethod
	def findinHist():
		return True

	@staticmethod
	def reverseRec():
		try:
			
			AuthLevel 	= g.getNAuthorize
			ID 			= g.formID
			Check 		= mktteller.validationReverse(MKT_FUND_TRANSFER, MKT_FUND_TRANSFER_INAU, ID)
		
			if not Check[0]:
				
				Audit 		= mktaudit.getAuditrail()
				Inputter	= Audit['Inputter']
				Createdon 	= Audit['Createdon']
				
				CheckAccounting = mktteller.setReverse('FundTransfer', AuthLevel, 'PF', MKT_FUND_TRANSFER, MKT_FUND_TRANSFER_INAU, ID, Inputter, Createdon)
					
				if not CheckAccounting[0]:
					# Catch error
					db.session.rollback()
					db.session.close()
					return True,CheckAccounting[1]

				db.session.commit()
				if int(AuthLevel) == 0:
					Msg = "The record reversed successfully, record id:%sR"%ID
				else:
					Msg = "The record reversed successfully, record id:%sR in INAU"%ID

				return True,Msg
			
			else:
				return Check

		except Exception, e:
			db.session.rollback()
			db.session.close()
			return True, msg_error+"%s"%e
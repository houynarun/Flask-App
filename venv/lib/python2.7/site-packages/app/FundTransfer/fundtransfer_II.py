from flask 						import flash
from wtforms 					import DecimalField, IntegerField
from app.mktcore.wtfimports 	import *
from .models 					import *
import time
from .. 						import app, db

from app.Transaction.models 	import MKT_TRANSACTION
from app.Account.models 		import MKT_ACCOUNT
from app.AccEntry.models 		import MKT_ACC_ENTRY
from app.Journal.models 		import MKT_JOURNAL
from app.AccProduct.models 		import MKT_ACC_PRODUCT
from app.AccRuleDetail.models 	import MKT_ACC_RULE_DE
from app.Currency.models 		import MKT_CURRENCY
from app.Category.models 		import MKT_CATEGORY

from .forms 					import *

from decimal 					import *
import app.tools.mktaccount 			as mktaccount
import app.tools.mktmoney 				as mktmoney
import app.tools.mktdate 				as mktdate
import app.tools.user 					as mktuser
import app.tools.mktaccounting 			as mktaccounting
import app.tools.mktloanapplication 	as mktloanapp
import app.tools.mktfundtransfer 		as mktfundtransfer
import app.tools.mktteller 				as mktteller
import app.tools.mktaudit 				as mktaudit
import app.tools.mktsetting 			as mktsetting

def loadCategory():

	JOURNAL_ENTRY_EXCLUDED = mktsetting.getExcludedCategories()

	return 	MKT_CATEGORY.query.\
			filter(~MKT_CATEGORY.ID.in_(JOURNAL_ENTRY_EXCLUDED)).\
			all()

def loadCurrency():
	return MKT_CURRENCY.query

def loadDefaultCurrency():
	return mktaccounting.getDefaultCurrency()

class FRM_FUND_TRANSFER_II(exform):

	DrAccount 		= 	RemoteTextField(getLanguage("Dr Account"))
	DrCategory 		= 	QuerySelectField(requiredlabel("Debit Category","*"),
							query_factory=loadCategory,
							get_label=lambda a: a.ID + " - " + a.Description,
							allow_blank=True,
							blank_text=u'',
							validators=[validators.Required()]
						)

	CrAccount 		= 	RemoteTextField(getLanguage("Cr Account"))
	CrCategory 		= 	QuerySelectField(requiredlabel("Credit Category","*"),
							query_factory=loadCategory,
							get_label=lambda a: a.ID + " - " + a.Description,
							allow_blank=True,
							blank_text=u'',
							validators=[validators.Required()]
						)

	CrCurrency 		= 	QuerySelectField(requiredlabel('Currency', "*"),
	                        query_factory=loadCurrency,
	                        get_label=u'ID',
	                        allow_blank=loadDefaultCurrency(),
	                        blank_text=u'--None--',
	                        validators=[validators.Required()]
                        )

	Amount 			= 	DecimalField(requiredlabel(getLanguage("Amount"), "*"), [validators.Required()], default=0)
	Transaction 	= 	QuerySelectField(requiredlabel(getLanguage("Transaction"), "*"),
							query_factory=loadTransaction,
							get_label=u'Description',
							allow_blank=True,
							blank_text=u'--%s--' %getLanguage("Choose Transaction"),
							validators=[validators.Required()]
						)

	TranDate 		= 	DateField(requiredlabel(getLanguage("Transaction Date"), "*"), [validators.Required()], default=loadCurrentDate)
	Reference 		= 	TextField(getLanguage("Reference"))
	Note 			= 	TextAreaField(getLanguage("Note"))

	def validate_DrAccount(form, field):
		try:

			AccID 		= form.DrAccount.data
			CurrencyDr 	= request.form['CrCurrency']
			Amo 		= Decimal(form.Amount.data)
			# mktaccounting.checkMaxMinBalance(AccID, CurrencyDr, Amo, 'Dr')
			# CheckBalance = mktaccounting.checkMaxMinBalance(AccID, CurrencyDr, Decimal(Amo), "Dr")
			# if CheckBalance:
				
			# 	raise ValidationError(CheckBalance)

			if str(form.DrAccount.data) == str(form.CrAccount.data):
				raise ValidationError("Sender account must be different receiver account.")

		except:
			raise

	def validate_CrAccount(form, field):
		try:

			AccID 		= form.CrAccount.data
			AccDr 		= form.DrAccount.data
			CurrencyCr 	= request.form['CrCurrency']
			Amo 		= Decimal(form.Amount.data)

			CrA 		= MKT_ACCOUNT.query.get(AccID)
			DrA 		= MKT_ACCOUNT.query.get(AccDr)
			
			CrBranch 	= ""
			DrBranch 	= ""

			if CrA:
				CrBranch 	= CrA.Branch
				CrBranch 	= CrBranch.strip()

			if DrA:
				DrBranch 	= DrA.Branch
				DrBranch 	= DrBranch.strip()

			# if CrBranch.upper() not in DrBranch.upper():
			# 	raise ValidationError("Fund transfer will not be allow to transfer across branch at the moment.")

			# mktaccounting.checkMaxMinBalance(AccID, CurrencyCr, Amo, 'Cr')
			# CheckBalance = mktaccounting.checkMaxMinBalance(AccID, CurrencyCr, Decimal(Amo), "Cr")
			# if CheckBalance:
				
			# 	raise ValidationError(CheckBalance)

		except:
			raise

	def validate_Amount(form, field):
		try:

			Amo 		= Decimal(form.Amount.data)
			DrAccountID = form.DrAccount.data
			BalDebit 	= MKT_ACCOUNT.query.get(DrAccountID)
			CurrencyDr 	= request.form['CrCurrency']
			CurrencyObj = MKT_CURRENCY.query.get(CurrencyDr)

			if Amo <= 0:
				raise ValidationError("Transaction amount must bigger than %s." %mktmoney.toMoney(float(Amo), CurrencyObj, 2))
			
		except:
			raise

	def validate_TranDate(form, field):

		TranDate 	= form.TranDate.data

		try:

			TranDate = datetime.strptime(str(TranDate),'%Y-%m-%d').date()

		except:
			raise ValidationError("This field must be in date format.")

		Check = mktfundtransfer.checkPreMonthDateTransaction(TranDate)

		if Check:

			raise ValidationError(Check)

	@staticmethod
	def moneyField():
		return [("Amount", 'CrCurrency')]

	@staticmethod
	def formatMoney():
		return ["Amount"], "CrCurrency"

	@staticmethod
	def hotField():
		hotfield = []

		fielddisplay 	= "$('#DrCategory').select2('data', {'id':data.DrCategory,'text':data.DrCategoryDesc}); $('#DrCurrency').val(data.DrCurrency)"
		varname 		= "DrAccountID:$('#DrAccount').val()"
		fun 			= ["DrAccount", varname, fielddisplay, "/Morakot/DrAccountID", "change"]
		hotfield.append(fun)

		fielddisplay = "$('#CrCategory').select2('data', {'id':data.DrCategory,'text':data.DrCategoryDesc}); $('#CrCurrency').val(data.DrCurrency)"
		varname = "DrAccountID:$('#CrAccount').val()"
		fun = ["CrAccount", varname, fielddisplay, "/Morakot/DrAccountID", "change"]
		hotfield.append(fun)

		return hotfield

	@staticmethod
	def setWidth():
		control_list = [('TranDate', len3)]

		return control_list

	# @staticmethod
	# def setDisable():
	# 	return [('DrCategory'), ('DrCurrency'), ('CrCategory'), ('CrCurrency'), ('Branch')]

	@staticmethod
	def listField():
		Fields = ["ID", "DrAccount", "CrAccount", "DrCurrency", "Amount", "Transaction", "TranDate"]

		return Fields, ["ID*LK*NC"]

	# @staticmethod
	# def formReadOnly():
	# 	return "AUTH"
		
	@staticmethod
	def findinHist():
		return True

	@staticmethod
	def beforeInsert():
		try:
			
			AuthLevel 	= g.getNAuthorize

			if AuthLevel == 0:

				DrAcc 		= request.form['DrAccount']
				DrCat 		= request.form['DrCategory']
				DrCur 		= request.form['CrCurrency']

				CrAcc 		= request.form['CrAccount']
				CrCat 		= request.form['CrCategory']
				CrCur 		= request.form['CrCurrency']

				Amo  		= Decimal(request.form['Amount'])
				Module 		= 'NC'
				Tran  		= request.form['Transaction']
				TranDate 	= request.form['TranDate']
				Ref 		= request.form['ID']
				Note 		= request.form['Note']

				Audit 		= mktaudit.getAuditrail()
				Inputter	= Audit['Inputter']
				Createdon 	= Audit['Createdon']
				Authorizer 	= Audit['Authorizer']
				Authorizeon	= Audit['Authorizeon']
				Branch 		= Audit['Branch']

				# Call function to commit add account by currency 
				CheckAccounting = setCommitAccouting(Inputter,Createdon,Authorizer,Authorizeon,Branch,DrAcc,DrCat,DrCur,CrAcc,CrCat,CrCur,Amo,Module,Tran,TranDate,Ref,Note)
				if not CheckAccounting[0]:
					flash(CheckAccounting[1])
					return False

			return True

		except:
			db.session.rollback()
			raise
			return False

	@staticmethod
	def beforeAuthorize():
		try:
			
			# ID 			= g.formID
			ID 			= 	g.formID
			Withdrawal 	=	MKT_FUND_TRANSFER_INAU.query.get(ID)
			
			if not Withdrawal:

				flash(msg_error + "Fundtransfer %s not found." %ID)
				return False

			else:

				# Amo 		=	Withdrawal.Amount if Withdrawal.Amount else 0
				# DrAccount 	=	Withdrawal.DrAccount
				# DrCurrency 	=	Withdrawal.DrCurrency

				DrAcc 		= Withdrawal.DrAccount
				DrCat 		= Withdrawal.DrCategory
				DrCur 		= Withdrawal.CrCurrency

				CrAcc 		= Withdrawal.CrAccount
				CrCat 		= Withdrawal.CrCategory
				CrCur 		= Withdrawal.CrCurrency

				Amo  		= Decimal(Withdrawal.Amount)
				Module 		= 'NC'
				Tran  		= Withdrawal.Transaction
				TranDate 	= Withdrawal.TranDate
				Ref 		= Withdrawal.ID
				Note 		= Withdrawal.Note

				# Audit 		= mktaudit.getAuditrail()
				Inputter	= Withdrawal.Inputter
				Createdon 	= Withdrawal.Createdon
				Authorizer 	= Withdrawal.Authorizer
				Authorizeon	= Withdrawal.Authorizeon
				Branch 		= Withdrawal.Branch

				# Call function to commit add account by currency 
				CheckAccounting = setCommitAccouting(Inputter,Createdon,Authorizer,Authorizeon,Branch,DrAcc,DrCat,DrCur,CrAcc,CrCat,CrCur,Amo,Module,Tran,TranDate,Ref,Note)
				if not CheckAccounting[0]:
					flash(CheckAccounting[1])
					return False

				# CheckBalance1 = mktaccounting.checkMaxMinBalance(DrAccount, DrCurrency, Decimal(Amo), "Dr")
				
				# if CheckBalance1:

				# 	flash(msg_error + CheckBalance1)
				# 	return False

				# CrAccount 	=	Withdrawal.CrAccount
				# CrCurrency 	=	Withdrawal.CrCurrency
				# CheckBalance2 = mktaccounting.checkMaxMinBalance(CrAccount, CrCurrency, Decimal(Amo), "Cr")

				# if CheckBalance2:
					
				# 	flash(msg_error + CheckBalance2)
				# 	return False

				# CheckAccounting = mktteller.setAuthorize('FT',MKT_FUND_TRANSFER,MKT_FUND_TRANSFER_INAU,ID)
				# if not CheckAccounting[0]:
				# 	db.session.rollback()
				# 	db.session.close()
				# 	flash(CheckAccounting[1])
				# 	return False

			# mktteller.setAuthorize('FT',MKT_FUND_TRANSFER,MKT_FUND_TRANSFER_INAU,ID)
			# db.session.commit()
			return True

		except Exception, e:
			flash(msg_error+'%s'%e)
			db.session.rollback()
			db.session.close()
			return False

	# @staticmethod
	# def reverseRec():

	# 	try:
			
	# 		AuthLevel 	= g.getNAuthorize
	# 		# print 'reverseRec: %s'% AuthLevel
	# 		ID 			= g.formID
	# 		FundTransfer 	=	MKT_FUND_TRANSFER.query.get(ID)
			
	# 		if not FundTransfer:

	# 			return True, "%s Fund advance %s not found." %(msg_error, ID)

	# 		else:

	# 			Amo 		=	FundTransfer.Amount if FundTransfer.Amount else 0
	# 			DrAccount 	=	FundTransfer.CrAccount
	# 			DrCurrency 	=	FundTransfer.CrCurrency

	# 			CheckBalance1 = mktaccounting.checkMaxMinBalance(DrAccount, DrCurrency, Decimal(Amo), "Dr")
				
	# 			if CheckBalance1:
	# 				db.session.rollback()
	# 				return True, "%s %s" %(msg_error, CheckBalance1)

	# 			CrAccount 	=	FundTransfer.DrAccount
	# 			CrCurrency 	=	FundTransfer.DrCurrency
	# 			CheckBalance2 = mktaccounting.checkMaxMinBalance(CrAccount, CrCurrency, Decimal(Amo), "Cr")

	# 			if CheckBalance2:
	# 				db.session.rollback()
	# 				return True, "%s %s" %(msg_error, CheckBalance2)

	# 			Check = mktteller.validationReverse(MKT_FUND_TRANSFER,MKT_FUND_TRANSFER_INAU,ID)

	# 			if not Check[0]:
	# 				Audit 		= mktaudit.getAuditrail()
	# 				Inputter	= Audit['Inputter']
	# 				Createdon 	= Audit['Createdon']
	# 				CheckAccounting = mktteller.setReverse('Fundtransfer',AuthLevel,'FT',MKT_FUND_TRANSFER,MKT_FUND_TRANSFER_INAU,ID,Inputter,Createdon)
					
	# 				if not CheckAccounting[0]:
	# 					#Catch error
	# 					db.session.rollback()
	# 					db.session.close()
	# 					return True,CheckAccounting[1]

	# 				#Successfully
	# 				db.session.commit()
	# 				db.session.close()
	# 				return True,CheckAccounting[1]
	# 			else:
	# 				return Check

	# 	except Exception, e:
	# 		db.session.rollback()
	# 		db.session.close()
	# 		return True,msg_error+"%s"%e

	@staticmethod
	def reverseRec():
		return False,"Record not allow to reverse."
		
	@staticmethod
	def IsAcceptOverride():

		Override 	= True
		DrAccount 	= request.form['DrAccount']
		DrCategory 	= request.form['DrCategory']
		CrAccount 	= request.form['CrAccount']
		CrCategory 	= request.form['CrCategory']
		Currency 	= request.form['CrCurrency']
		Amount 		= request.form['Amount']
		Msg 		= "The amount %s " %mktmoney.toMoney(float(Amount), mktmoney.getCurrencyObj(Currency), 2)
		Msg 		+= "will transfer from account#%s category-%s to account#%s category-%s. " %(DrAccount,DrCategory, CrAccount,CrCategory)
		Msg 		+= "Do you want to procceed?"
		
		return Override, Msg


def setCommitAccouting(Inputter,Createdon,Authorizer,Authorizeon,Branch,DrAcc,DrCat,DrCur,CrAcc,CrCat,CrCur,Amo,Module,Tran,TranDate,Ref,Note,Mode="",EOD=0):
	try:
		
		Message = ""
		for i in range(0, 2):
		
			if i == 0:
				Account 	= DrAcc
				Category	= DrCat
				Currency 	= DrCur
				DrCr 		= "Dr"
			else:
				Account		= CrAcc
				Category	= CrCat
				Currency 	= CrCur
				DrCr 		= "Cr"

			if Account:
				Mode = ""
			else:
				Mode = "Direct"

			#get Gl key	
			GL_KEYS 		= mktaccounting.getConsolKey(Category,Currency,"","")
				
			ObjAccounting 	= mktaccounting.postAccounting(		

										"AUTH", 				# Status
										"0", 					# Curr
										Inputter,				# Inputter
										Createdon, 				# Createdon
										Authorizer,				# Authorizer
										Authorizeon,			# Authorizeon
										"", 					# AEID
										Account,				# Account
										Category,				# Category
										Currency,				# Currency
										DrCr,					# DrCr
										Amo, 					# Amount
										Module,					# Module
										Tran, 					# Transaction
										TranDate, 				# TransactionDate
										Ref, 					# Reference
										Note, 					# Note
										"", 					# JNID
										Branch,					# Branch
										GL_KEYS,				# ConsolKey
										Mode,					# Mode
										"YES",
										EOD=EOD)					# Tell function to update LastTransaction Customer's Account

		#Check after post accounting
		# CheckPointObj = mktaccounting.setAccoutningCheckPoint(Module,Ref)
		# if not CheckPointObj[0]:
		# 	db.session.rollback()
		# 	return False,CheckPointObj[1]
		#Pass
		return True,""

	except Exception, e:
		db.session.rollback()
		return False," %s"%e